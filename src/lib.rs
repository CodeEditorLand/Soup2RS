// This file was generated by gir (0d8699e+) from gir-files (11e0e6d)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]

extern crate libc;
#[macro_use] extern crate bitflags;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gio_sys as gio;

use libc::sockaddr;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType, Volatile};


#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupAddressFamily {
    Invalid = -1,
    Ipv4 = 2,
    Ipv6 = 10,
}
pub const SOUP_ADDRESS_FAMILY_INVALID: SoupAddressFamily = SoupAddressFamily::Invalid;
pub const SOUP_ADDRESS_FAMILY_IPV4: SoupAddressFamily = SoupAddressFamily::Ipv4;
pub const SOUP_ADDRESS_FAMILY_IPV6: SoupAddressFamily = SoupAddressFamily::Ipv6;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupCacheResponse {
    Fresh = 0,
    NeedsValidation = 1,
    Stale = 2,
}
pub const SOUP_CACHE_RESPONSE_FRESH: SoupCacheResponse = SoupCacheResponse::Fresh;
pub const SOUP_CACHE_RESPONSE_NEEDS_VALIDATION: SoupCacheResponse = SoupCacheResponse::NeedsValidation;
pub const SOUP_CACHE_RESPONSE_STALE: SoupCacheResponse = SoupCacheResponse::Stale;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupCacheType {
    SingleUser = 0,
    Shared = 1,
}
pub const SOUP_CACHE_SINGLE_USER: SoupCacheType = SoupCacheType::SingleUser;
pub const SOUP_CACHE_SHARED: SoupCacheType = SoupCacheType::Shared;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupConnectionState {
    New = 0,
    Connecting = 1,
    Idle = 2,
    InUse = 3,
    RemoteDisconnected = 4,
    Disconnected = 5,
}
pub const SOUP_CONNECTION_NEW: SoupConnectionState = SoupConnectionState::New;
pub const SOUP_CONNECTION_CONNECTING: SoupConnectionState = SoupConnectionState::Connecting;
pub const SOUP_CONNECTION_IDLE: SoupConnectionState = SoupConnectionState::Idle;
pub const SOUP_CONNECTION_IN_USE: SoupConnectionState = SoupConnectionState::InUse;
pub const SOUP_CONNECTION_REMOTE_DISCONNECTED: SoupConnectionState = SoupConnectionState::RemoteDisconnected;
pub const SOUP_CONNECTION_DISCONNECTED: SoupConnectionState = SoupConnectionState::Disconnected;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupCookieJarAcceptPolicy {
    Always = 0,
    Never = 1,
    NoThirdParty = 2,
}
pub const SOUP_COOKIE_JAR_ACCEPT_ALWAYS: SoupCookieJarAcceptPolicy = SoupCookieJarAcceptPolicy::Always;
pub const SOUP_COOKIE_JAR_ACCEPT_NEVER: SoupCookieJarAcceptPolicy = SoupCookieJarAcceptPolicy::Never;
pub const SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY: SoupCookieJarAcceptPolicy = SoupCookieJarAcceptPolicy::NoThirdParty;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupDateFormat {
    Http = 1,
    Cookie = 2,
    Rfc2822 = 3,
    Iso8601Compact = 4,
    Iso8601Full = 5,
    Iso8601Xmlrpc = 6,
}
pub const SOUP_DATE_HTTP: SoupDateFormat = SoupDateFormat::Http;
pub const SOUP_DATE_COOKIE: SoupDateFormat = SoupDateFormat::Cookie;
pub const SOUP_DATE_RFC2822: SoupDateFormat = SoupDateFormat::Rfc2822;
pub const SOUP_DATE_ISO8601_COMPACT: SoupDateFormat = SoupDateFormat::Iso8601Compact;
pub const SOUP_DATE_ISO8601_FULL: SoupDateFormat = SoupDateFormat::Iso8601Full;
pub const SOUP_DATE_ISO8601: SoupDateFormat = SoupDateFormat::Iso8601Full;
pub const SOUP_DATE_ISO8601_XMLRPC: SoupDateFormat = SoupDateFormat::Iso8601Xmlrpc;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupEncoding {
    Unrecognized = 0,
    None = 1,
    ContentLength = 2,
    Eof = 3,
    Chunked = 4,
    Byteranges = 5,
}
pub const SOUP_ENCODING_UNRECOGNIZED: SoupEncoding = SoupEncoding::Unrecognized;
pub const SOUP_ENCODING_NONE: SoupEncoding = SoupEncoding::None;
pub const SOUP_ENCODING_CONTENT_LENGTH: SoupEncoding = SoupEncoding::ContentLength;
pub const SOUP_ENCODING_EOF: SoupEncoding = SoupEncoding::Eof;
pub const SOUP_ENCODING_CHUNKED: SoupEncoding = SoupEncoding::Chunked;
pub const SOUP_ENCODING_BYTERANGES: SoupEncoding = SoupEncoding::Byteranges;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupHTTPVersion {
    Http10 = 0,
    Http11 = 1,
}
pub const SOUP_HTTP_1_0: SoupHTTPVersion = SoupHTTPVersion::Http10;
pub const SOUP_HTTP_1_1: SoupHTTPVersion = SoupHTTPVersion::Http11;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupKnownStatusCode {
    None = 0,
    Cancelled = 1,
    CantResolve = 2,
    CantResolveProxy = 3,
    CantConnect = 4,
    CantConnectProxy = 5,
    SslFailed = 6,
    IoError = 7,
    Malformed = 8,
    TryAgain = 9,
    TooManyRedirects = 10,
    TlsFailed = 11,
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    Ok = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritative = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    MultipleChoices = 300,
    MovedPermanently = 301,
    Found = 302,
    SeeOther = 303,
    NotModified = 304,
    UseProxy = 305,
    NotAppearingInThisProtocol = 306,
    TemporaryRedirect = 307,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    InsufficientStorage = 507,
    NotExtended = 510,
}
pub const SOUP_KNOWN_STATUS_CODE_NONE: SoupKnownStatusCode = SoupKnownStatusCode::None;
pub const SOUP_KNOWN_STATUS_CODE_CANCELLED: SoupKnownStatusCode = SoupKnownStatusCode::Cancelled;
pub const SOUP_KNOWN_STATUS_CODE_CANT_RESOLVE: SoupKnownStatusCode = SoupKnownStatusCode::CantResolve;
pub const SOUP_KNOWN_STATUS_CODE_CANT_RESOLVE_PROXY: SoupKnownStatusCode = SoupKnownStatusCode::CantResolveProxy;
pub const SOUP_KNOWN_STATUS_CODE_CANT_CONNECT: SoupKnownStatusCode = SoupKnownStatusCode::CantConnect;
pub const SOUP_KNOWN_STATUS_CODE_CANT_CONNECT_PROXY: SoupKnownStatusCode = SoupKnownStatusCode::CantConnectProxy;
pub const SOUP_KNOWN_STATUS_CODE_SSL_FAILED: SoupKnownStatusCode = SoupKnownStatusCode::SslFailed;
pub const SOUP_KNOWN_STATUS_CODE_IO_ERROR: SoupKnownStatusCode = SoupKnownStatusCode::IoError;
pub const SOUP_KNOWN_STATUS_CODE_MALFORMED: SoupKnownStatusCode = SoupKnownStatusCode::Malformed;
pub const SOUP_KNOWN_STATUS_CODE_TRY_AGAIN: SoupKnownStatusCode = SoupKnownStatusCode::TryAgain;
pub const SOUP_KNOWN_STATUS_CODE_TOO_MANY_REDIRECTS: SoupKnownStatusCode = SoupKnownStatusCode::TooManyRedirects;
pub const SOUP_KNOWN_STATUS_CODE_TLS_FAILED: SoupKnownStatusCode = SoupKnownStatusCode::TlsFailed;
pub const SOUP_KNOWN_STATUS_CODE_CONTINUE: SoupKnownStatusCode = SoupKnownStatusCode::Continue;
pub const SOUP_KNOWN_STATUS_CODE_SWITCHING_PROTOCOLS: SoupKnownStatusCode = SoupKnownStatusCode::SwitchingProtocols;
pub const SOUP_KNOWN_STATUS_CODE_PROCESSING: SoupKnownStatusCode = SoupKnownStatusCode::Processing;
pub const SOUP_KNOWN_STATUS_CODE_OK: SoupKnownStatusCode = SoupKnownStatusCode::Ok;
pub const SOUP_KNOWN_STATUS_CODE_CREATED: SoupKnownStatusCode = SoupKnownStatusCode::Created;
pub const SOUP_KNOWN_STATUS_CODE_ACCEPTED: SoupKnownStatusCode = SoupKnownStatusCode::Accepted;
pub const SOUP_KNOWN_STATUS_CODE_NON_AUTHORITATIVE: SoupKnownStatusCode = SoupKnownStatusCode::NonAuthoritative;
pub const SOUP_KNOWN_STATUS_CODE_NO_CONTENT: SoupKnownStatusCode = SoupKnownStatusCode::NoContent;
pub const SOUP_KNOWN_STATUS_CODE_RESET_CONTENT: SoupKnownStatusCode = SoupKnownStatusCode::ResetContent;
pub const SOUP_KNOWN_STATUS_CODE_PARTIAL_CONTENT: SoupKnownStatusCode = SoupKnownStatusCode::PartialContent;
pub const SOUP_KNOWN_STATUS_CODE_MULTI_STATUS: SoupKnownStatusCode = SoupKnownStatusCode::MultiStatus;
pub const SOUP_KNOWN_STATUS_CODE_MULTIPLE_CHOICES: SoupKnownStatusCode = SoupKnownStatusCode::MultipleChoices;
pub const SOUP_KNOWN_STATUS_CODE_MOVED_PERMANENTLY: SoupKnownStatusCode = SoupKnownStatusCode::MovedPermanently;
pub const SOUP_KNOWN_STATUS_CODE_FOUND: SoupKnownStatusCode = SoupKnownStatusCode::Found;
pub const SOUP_KNOWN_STATUS_CODE_MOVED_TEMPORARILY: SoupKnownStatusCode = SoupKnownStatusCode::Found;
pub const SOUP_KNOWN_STATUS_CODE_SEE_OTHER: SoupKnownStatusCode = SoupKnownStatusCode::SeeOther;
pub const SOUP_KNOWN_STATUS_CODE_NOT_MODIFIED: SoupKnownStatusCode = SoupKnownStatusCode::NotModified;
pub const SOUP_KNOWN_STATUS_CODE_USE_PROXY: SoupKnownStatusCode = SoupKnownStatusCode::UseProxy;
pub const SOUP_KNOWN_STATUS_CODE_NOT_APPEARING_IN_THIS_PROTOCOL: SoupKnownStatusCode = SoupKnownStatusCode::NotAppearingInThisProtocol;
pub const SOUP_KNOWN_STATUS_CODE_TEMPORARY_REDIRECT: SoupKnownStatusCode = SoupKnownStatusCode::TemporaryRedirect;
pub const SOUP_KNOWN_STATUS_CODE_BAD_REQUEST: SoupKnownStatusCode = SoupKnownStatusCode::BadRequest;
pub const SOUP_KNOWN_STATUS_CODE_UNAUTHORIZED: SoupKnownStatusCode = SoupKnownStatusCode::Unauthorized;
pub const SOUP_KNOWN_STATUS_CODE_PAYMENT_REQUIRED: SoupKnownStatusCode = SoupKnownStatusCode::PaymentRequired;
pub const SOUP_KNOWN_STATUS_CODE_FORBIDDEN: SoupKnownStatusCode = SoupKnownStatusCode::Forbidden;
pub const SOUP_KNOWN_STATUS_CODE_NOT_FOUND: SoupKnownStatusCode = SoupKnownStatusCode::NotFound;
pub const SOUP_KNOWN_STATUS_CODE_METHOD_NOT_ALLOWED: SoupKnownStatusCode = SoupKnownStatusCode::MethodNotAllowed;
pub const SOUP_KNOWN_STATUS_CODE_NOT_ACCEPTABLE: SoupKnownStatusCode = SoupKnownStatusCode::NotAcceptable;
pub const SOUP_KNOWN_STATUS_CODE_PROXY_AUTHENTICATION_REQUIRED: SoupKnownStatusCode = SoupKnownStatusCode::ProxyAuthenticationRequired;
pub const SOUP_KNOWN_STATUS_CODE_PROXY_UNAUTHORIZED: SoupKnownStatusCode = SoupKnownStatusCode::ProxyAuthenticationRequired;
pub const SOUP_KNOWN_STATUS_CODE_REQUEST_TIMEOUT: SoupKnownStatusCode = SoupKnownStatusCode::RequestTimeout;
pub const SOUP_KNOWN_STATUS_CODE_CONFLICT: SoupKnownStatusCode = SoupKnownStatusCode::Conflict;
pub const SOUP_KNOWN_STATUS_CODE_GONE: SoupKnownStatusCode = SoupKnownStatusCode::Gone;
pub const SOUP_KNOWN_STATUS_CODE_LENGTH_REQUIRED: SoupKnownStatusCode = SoupKnownStatusCode::LengthRequired;
pub const SOUP_KNOWN_STATUS_CODE_PRECONDITION_FAILED: SoupKnownStatusCode = SoupKnownStatusCode::PreconditionFailed;
pub const SOUP_KNOWN_STATUS_CODE_REQUEST_ENTITY_TOO_LARGE: SoupKnownStatusCode = SoupKnownStatusCode::RequestEntityTooLarge;
pub const SOUP_KNOWN_STATUS_CODE_REQUEST_URI_TOO_LONG: SoupKnownStatusCode = SoupKnownStatusCode::RequestUriTooLong;
pub const SOUP_KNOWN_STATUS_CODE_UNSUPPORTED_MEDIA_TYPE: SoupKnownStatusCode = SoupKnownStatusCode::UnsupportedMediaType;
pub const SOUP_KNOWN_STATUS_CODE_REQUESTED_RANGE_NOT_SATISFIABLE: SoupKnownStatusCode = SoupKnownStatusCode::RequestedRangeNotSatisfiable;
pub const SOUP_KNOWN_STATUS_CODE_INVALID_RANGE: SoupKnownStatusCode = SoupKnownStatusCode::RequestedRangeNotSatisfiable;
pub const SOUP_KNOWN_STATUS_CODE_EXPECTATION_FAILED: SoupKnownStatusCode = SoupKnownStatusCode::ExpectationFailed;
pub const SOUP_KNOWN_STATUS_CODE_UNPROCESSABLE_ENTITY: SoupKnownStatusCode = SoupKnownStatusCode::UnprocessableEntity;
pub const SOUP_KNOWN_STATUS_CODE_LOCKED: SoupKnownStatusCode = SoupKnownStatusCode::Locked;
pub const SOUP_KNOWN_STATUS_CODE_FAILED_DEPENDENCY: SoupKnownStatusCode = SoupKnownStatusCode::FailedDependency;
pub const SOUP_KNOWN_STATUS_CODE_INTERNAL_SERVER_ERROR: SoupKnownStatusCode = SoupKnownStatusCode::InternalServerError;
pub const SOUP_KNOWN_STATUS_CODE_NOT_IMPLEMENTED: SoupKnownStatusCode = SoupKnownStatusCode::NotImplemented;
pub const SOUP_KNOWN_STATUS_CODE_BAD_GATEWAY: SoupKnownStatusCode = SoupKnownStatusCode::BadGateway;
pub const SOUP_KNOWN_STATUS_CODE_SERVICE_UNAVAILABLE: SoupKnownStatusCode = SoupKnownStatusCode::ServiceUnavailable;
pub const SOUP_KNOWN_STATUS_CODE_GATEWAY_TIMEOUT: SoupKnownStatusCode = SoupKnownStatusCode::GatewayTimeout;
pub const SOUP_KNOWN_STATUS_CODE_HTTP_VERSION_NOT_SUPPORTED: SoupKnownStatusCode = SoupKnownStatusCode::HttpVersionNotSupported;
pub const SOUP_KNOWN_STATUS_CODE_INSUFFICIENT_STORAGE: SoupKnownStatusCode = SoupKnownStatusCode::InsufficientStorage;
pub const SOUP_KNOWN_STATUS_CODE_NOT_EXTENDED: SoupKnownStatusCode = SoupKnownStatusCode::NotExtended;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupLoggerLogLevel {
    None = 0,
    Minimal = 1,
    Headers = 2,
    Body = 3,
}
pub const SOUP_LOGGER_LOG_NONE: SoupLoggerLogLevel = SoupLoggerLogLevel::None;
pub const SOUP_LOGGER_LOG_MINIMAL: SoupLoggerLogLevel = SoupLoggerLogLevel::Minimal;
pub const SOUP_LOGGER_LOG_HEADERS: SoupLoggerLogLevel = SoupLoggerLogLevel::Headers;
pub const SOUP_LOGGER_LOG_BODY: SoupLoggerLogLevel = SoupLoggerLogLevel::Body;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupMemoryUse {
    Static = 0,
    Take = 1,
    Copy = 2,
    Temporary = 3,
}
pub const SOUP_MEMORY_STATIC: SoupMemoryUse = SoupMemoryUse::Static;
pub const SOUP_MEMORY_TAKE: SoupMemoryUse = SoupMemoryUse::Take;
pub const SOUP_MEMORY_COPY: SoupMemoryUse = SoupMemoryUse::Copy;
pub const SOUP_MEMORY_TEMPORARY: SoupMemoryUse = SoupMemoryUse::Temporary;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupMessageHeadersType {
    Request = 0,
    Response = 1,
    Multipart = 2,
}
pub const SOUP_MESSAGE_HEADERS_REQUEST: SoupMessageHeadersType = SoupMessageHeadersType::Request;
pub const SOUP_MESSAGE_HEADERS_RESPONSE: SoupMessageHeadersType = SoupMessageHeadersType::Response;
pub const SOUP_MESSAGE_HEADERS_MULTIPART: SoupMessageHeadersType = SoupMessageHeadersType::Multipart;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupMessagePriority {
    VeryLow = 0,
    Low = 1,
    Normal = 2,
    High = 3,
    VeryHigh = 4,
}
pub const SOUP_MESSAGE_PRIORITY_VERY_LOW: SoupMessagePriority = SoupMessagePriority::VeryLow;
pub const SOUP_MESSAGE_PRIORITY_LOW: SoupMessagePriority = SoupMessagePriority::Low;
pub const SOUP_MESSAGE_PRIORITY_NORMAL: SoupMessagePriority = SoupMessagePriority::Normal;
pub const SOUP_MESSAGE_PRIORITY_HIGH: SoupMessagePriority = SoupMessagePriority::High;
pub const SOUP_MESSAGE_PRIORITY_VERY_HIGH: SoupMessagePriority = SoupMessagePriority::VeryHigh;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupRequestError {
    BadUri = 0,
    UnsupportedUriScheme = 1,
    Parsing = 2,
    Encoding = 3,
}
pub const SOUP_REQUEST_ERROR_BAD_URI: SoupRequestError = SoupRequestError::BadUri;
pub const SOUP_REQUEST_ERROR_UNSUPPORTED_URI_SCHEME: SoupRequestError = SoupRequestError::UnsupportedUriScheme;
pub const SOUP_REQUEST_ERROR_PARSING: SoupRequestError = SoupRequestError::Parsing;
pub const SOUP_REQUEST_ERROR_ENCODING: SoupRequestError = SoupRequestError::Encoding;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupRequesterError {
    BadUri = 0,
    UnsupportedUriScheme = 1,
}
pub const SOUP_REQUESTER_ERROR_BAD_URI: SoupRequesterError = SoupRequesterError::BadUri;
pub const SOUP_REQUESTER_ERROR_UNSUPPORTED_URI_SCHEME: SoupRequesterError = SoupRequesterError::UnsupportedUriScheme;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupSocketIOStatus {
    Ok = 0,
    WouldBlock = 1,
    Eof = 2,
    Error = 3,
}
pub const SOUP_SOCKET_OK: SoupSocketIOStatus = SoupSocketIOStatus::Ok;
pub const SOUP_SOCKET_WOULD_BLOCK: SoupSocketIOStatus = SoupSocketIOStatus::WouldBlock;
pub const SOUP_SOCKET_EOF: SoupSocketIOStatus = SoupSocketIOStatus::Eof;
pub const SOUP_SOCKET_ERROR: SoupSocketIOStatus = SoupSocketIOStatus::Error;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupStatus {
    None = 0,
    Cancelled = 1,
    CantResolve = 2,
    CantResolveProxy = 3,
    CantConnect = 4,
    CantConnectProxy = 5,
    SslFailed = 6,
    IoError = 7,
    Malformed = 8,
    TryAgain = 9,
    TooManyRedirects = 10,
    TlsFailed = 11,
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    Ok = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritative = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    MultipleChoices = 300,
    MovedPermanently = 301,
    Found = 302,
    SeeOther = 303,
    NotModified = 304,
    UseProxy = 305,
    NotAppearingInThisProtocol = 306,
    TemporaryRedirect = 307,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    InsufficientStorage = 507,
    NotExtended = 510,
}
pub const SOUP_STATUS_NONE: SoupStatus = SoupStatus::None;
pub const SOUP_STATUS_CANCELLED: SoupStatus = SoupStatus::Cancelled;
pub const SOUP_STATUS_CANT_RESOLVE: SoupStatus = SoupStatus::CantResolve;
pub const SOUP_STATUS_CANT_RESOLVE_PROXY: SoupStatus = SoupStatus::CantResolveProxy;
pub const SOUP_STATUS_CANT_CONNECT: SoupStatus = SoupStatus::CantConnect;
pub const SOUP_STATUS_CANT_CONNECT_PROXY: SoupStatus = SoupStatus::CantConnectProxy;
pub const SOUP_STATUS_SSL_FAILED: SoupStatus = SoupStatus::SslFailed;
pub const SOUP_STATUS_IO_ERROR: SoupStatus = SoupStatus::IoError;
pub const SOUP_STATUS_MALFORMED: SoupStatus = SoupStatus::Malformed;
pub const SOUP_STATUS_TRY_AGAIN: SoupStatus = SoupStatus::TryAgain;
pub const SOUP_STATUS_TOO_MANY_REDIRECTS: SoupStatus = SoupStatus::TooManyRedirects;
pub const SOUP_STATUS_TLS_FAILED: SoupStatus = SoupStatus::TlsFailed;
pub const SOUP_STATUS_CONTINUE: SoupStatus = SoupStatus::Continue;
pub const SOUP_STATUS_SWITCHING_PROTOCOLS: SoupStatus = SoupStatus::SwitchingProtocols;
pub const SOUP_STATUS_PROCESSING: SoupStatus = SoupStatus::Processing;
pub const SOUP_STATUS_OK: SoupStatus = SoupStatus::Ok;
pub const SOUP_STATUS_CREATED: SoupStatus = SoupStatus::Created;
pub const SOUP_STATUS_ACCEPTED: SoupStatus = SoupStatus::Accepted;
pub const SOUP_STATUS_NON_AUTHORITATIVE: SoupStatus = SoupStatus::NonAuthoritative;
pub const SOUP_STATUS_NO_CONTENT: SoupStatus = SoupStatus::NoContent;
pub const SOUP_STATUS_RESET_CONTENT: SoupStatus = SoupStatus::ResetContent;
pub const SOUP_STATUS_PARTIAL_CONTENT: SoupStatus = SoupStatus::PartialContent;
pub const SOUP_STATUS_MULTI_STATUS: SoupStatus = SoupStatus::MultiStatus;
pub const SOUP_STATUS_MULTIPLE_CHOICES: SoupStatus = SoupStatus::MultipleChoices;
pub const SOUP_STATUS_MOVED_PERMANENTLY: SoupStatus = SoupStatus::MovedPermanently;
pub const SOUP_STATUS_FOUND: SoupStatus = SoupStatus::Found;
pub const SOUP_STATUS_MOVED_TEMPORARILY: SoupStatus = SoupStatus::Found;
pub const SOUP_STATUS_SEE_OTHER: SoupStatus = SoupStatus::SeeOther;
pub const SOUP_STATUS_NOT_MODIFIED: SoupStatus = SoupStatus::NotModified;
pub const SOUP_STATUS_USE_PROXY: SoupStatus = SoupStatus::UseProxy;
pub const SOUP_STATUS_NOT_APPEARING_IN_THIS_PROTOCOL: SoupStatus = SoupStatus::NotAppearingInThisProtocol;
pub const SOUP_STATUS_TEMPORARY_REDIRECT: SoupStatus = SoupStatus::TemporaryRedirect;
pub const SOUP_STATUS_BAD_REQUEST: SoupStatus = SoupStatus::BadRequest;
pub const SOUP_STATUS_UNAUTHORIZED: SoupStatus = SoupStatus::Unauthorized;
pub const SOUP_STATUS_PAYMENT_REQUIRED: SoupStatus = SoupStatus::PaymentRequired;
pub const SOUP_STATUS_FORBIDDEN: SoupStatus = SoupStatus::Forbidden;
pub const SOUP_STATUS_NOT_FOUND: SoupStatus = SoupStatus::NotFound;
pub const SOUP_STATUS_METHOD_NOT_ALLOWED: SoupStatus = SoupStatus::MethodNotAllowed;
pub const SOUP_STATUS_NOT_ACCEPTABLE: SoupStatus = SoupStatus::NotAcceptable;
pub const SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED: SoupStatus = SoupStatus::ProxyAuthenticationRequired;
pub const SOUP_STATUS_PROXY_UNAUTHORIZED: SoupStatus = SoupStatus::ProxyAuthenticationRequired;
pub const SOUP_STATUS_REQUEST_TIMEOUT: SoupStatus = SoupStatus::RequestTimeout;
pub const SOUP_STATUS_CONFLICT: SoupStatus = SoupStatus::Conflict;
pub const SOUP_STATUS_GONE: SoupStatus = SoupStatus::Gone;
pub const SOUP_STATUS_LENGTH_REQUIRED: SoupStatus = SoupStatus::LengthRequired;
pub const SOUP_STATUS_PRECONDITION_FAILED: SoupStatus = SoupStatus::PreconditionFailed;
pub const SOUP_STATUS_REQUEST_ENTITY_TOO_LARGE: SoupStatus = SoupStatus::RequestEntityTooLarge;
pub const SOUP_STATUS_REQUEST_URI_TOO_LONG: SoupStatus = SoupStatus::RequestUriTooLong;
pub const SOUP_STATUS_UNSUPPORTED_MEDIA_TYPE: SoupStatus = SoupStatus::UnsupportedMediaType;
pub const SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE: SoupStatus = SoupStatus::RequestedRangeNotSatisfiable;
pub const SOUP_STATUS_INVALID_RANGE: SoupStatus = SoupStatus::RequestedRangeNotSatisfiable;
pub const SOUP_STATUS_EXPECTATION_FAILED: SoupStatus = SoupStatus::ExpectationFailed;
pub const SOUP_STATUS_UNPROCESSABLE_ENTITY: SoupStatus = SoupStatus::UnprocessableEntity;
pub const SOUP_STATUS_LOCKED: SoupStatus = SoupStatus::Locked;
pub const SOUP_STATUS_FAILED_DEPENDENCY: SoupStatus = SoupStatus::FailedDependency;
pub const SOUP_STATUS_INTERNAL_SERVER_ERROR: SoupStatus = SoupStatus::InternalServerError;
pub const SOUP_STATUS_NOT_IMPLEMENTED: SoupStatus = SoupStatus::NotImplemented;
pub const SOUP_STATUS_BAD_GATEWAY: SoupStatus = SoupStatus::BadGateway;
pub const SOUP_STATUS_SERVICE_UNAVAILABLE: SoupStatus = SoupStatus::ServiceUnavailable;
pub const SOUP_STATUS_GATEWAY_TIMEOUT: SoupStatus = SoupStatus::GatewayTimeout;
pub const SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED: SoupStatus = SoupStatus::HttpVersionNotSupported;
pub const SOUP_STATUS_INSUFFICIENT_STORAGE: SoupStatus = SoupStatus::InsufficientStorage;
pub const SOUP_STATUS_NOT_EXTENDED: SoupStatus = SoupStatus::NotExtended;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupTLDError {
    InvalidHostname = 0,
    IsIpAddress = 1,
    NotEnoughDomains = 2,
    NoBaseDomain = 3,
}
pub const SOUP_TLD_ERROR_INVALID_HOSTNAME: SoupTLDError = SoupTLDError::InvalidHostname;
pub const SOUP_TLD_ERROR_IS_IP_ADDRESS: SoupTLDError = SoupTLDError::IsIpAddress;
pub const SOUP_TLD_ERROR_NOT_ENOUGH_DOMAINS: SoupTLDError = SoupTLDError::NotEnoughDomains;
pub const SOUP_TLD_ERROR_NO_BASE_DOMAIN: SoupTLDError = SoupTLDError::NoBaseDomain;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupWebsocketCloseCode {
    Normal = 1000,
    GoingAway = 1001,
    ProtocolError = 1002,
    UnsupportedData = 1003,
    NoStatus = 1005,
    Abnormal = 1006,
    BadData = 1007,
    PolicyViolation = 1008,
    TooBig = 1009,
    NoExtension = 1010,
    ServerError = 1011,
    TlsHandshake = 1015,
}
pub const SOUP_WEBSOCKET_CLOSE_NORMAL: SoupWebsocketCloseCode = SoupWebsocketCloseCode::Normal;
pub const SOUP_WEBSOCKET_CLOSE_GOING_AWAY: SoupWebsocketCloseCode = SoupWebsocketCloseCode::GoingAway;
pub const SOUP_WEBSOCKET_CLOSE_PROTOCOL_ERROR: SoupWebsocketCloseCode = SoupWebsocketCloseCode::ProtocolError;
pub const SOUP_WEBSOCKET_CLOSE_UNSUPPORTED_DATA: SoupWebsocketCloseCode = SoupWebsocketCloseCode::UnsupportedData;
pub const SOUP_WEBSOCKET_CLOSE_NO_STATUS: SoupWebsocketCloseCode = SoupWebsocketCloseCode::NoStatus;
pub const SOUP_WEBSOCKET_CLOSE_ABNORMAL: SoupWebsocketCloseCode = SoupWebsocketCloseCode::Abnormal;
pub const SOUP_WEBSOCKET_CLOSE_BAD_DATA: SoupWebsocketCloseCode = SoupWebsocketCloseCode::BadData;
pub const SOUP_WEBSOCKET_CLOSE_POLICY_VIOLATION: SoupWebsocketCloseCode = SoupWebsocketCloseCode::PolicyViolation;
pub const SOUP_WEBSOCKET_CLOSE_TOO_BIG: SoupWebsocketCloseCode = SoupWebsocketCloseCode::TooBig;
pub const SOUP_WEBSOCKET_CLOSE_NO_EXTENSION: SoupWebsocketCloseCode = SoupWebsocketCloseCode::NoExtension;
pub const SOUP_WEBSOCKET_CLOSE_SERVER_ERROR: SoupWebsocketCloseCode = SoupWebsocketCloseCode::ServerError;
pub const SOUP_WEBSOCKET_CLOSE_TLS_HANDSHAKE: SoupWebsocketCloseCode = SoupWebsocketCloseCode::TlsHandshake;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupWebsocketConnectionType {
    Unknown = 0,
    Client = 1,
    Server = 2,
}
pub const SOUP_WEBSOCKET_CONNECTION_UNKNOWN: SoupWebsocketConnectionType = SoupWebsocketConnectionType::Unknown;
pub const SOUP_WEBSOCKET_CONNECTION_CLIENT: SoupWebsocketConnectionType = SoupWebsocketConnectionType::Client;
pub const SOUP_WEBSOCKET_CONNECTION_SERVER: SoupWebsocketConnectionType = SoupWebsocketConnectionType::Server;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupWebsocketDataType {
    Text = 1,
    Binary = 2,
}
pub const SOUP_WEBSOCKET_DATA_TEXT: SoupWebsocketDataType = SoupWebsocketDataType::Text;
pub const SOUP_WEBSOCKET_DATA_BINARY: SoupWebsocketDataType = SoupWebsocketDataType::Binary;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupWebsocketError {
    Failed = 0,
    NotWebsocket = 1,
    BadHandshake = 2,
    BadOrigin = 3,
}
pub const SOUP_WEBSOCKET_ERROR_FAILED: SoupWebsocketError = SoupWebsocketError::Failed;
pub const SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET: SoupWebsocketError = SoupWebsocketError::NotWebsocket;
pub const SOUP_WEBSOCKET_ERROR_BAD_HANDSHAKE: SoupWebsocketError = SoupWebsocketError::BadHandshake;
pub const SOUP_WEBSOCKET_ERROR_BAD_ORIGIN: SoupWebsocketError = SoupWebsocketError::BadOrigin;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupWebsocketState {
    Open = 1,
    Closing = 2,
    Closed = 3,
}
pub const SOUP_WEBSOCKET_STATE_OPEN: SoupWebsocketState = SoupWebsocketState::Open;
pub const SOUP_WEBSOCKET_STATE_CLOSING: SoupWebsocketState = SoupWebsocketState::Closing;
pub const SOUP_WEBSOCKET_STATE_CLOSED: SoupWebsocketState = SoupWebsocketState::Closed;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupXMLRPCError {
    Arguments = 0,
    Retval = 1,
}
pub const SOUP_XMLRPC_ERROR_ARGUMENTS: SoupXMLRPCError = SoupXMLRPCError::Arguments;
pub const SOUP_XMLRPC_ERROR_RETVAL: SoupXMLRPCError = SoupXMLRPCError::Retval;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum SoupXMLRPCFault {
    ParseErrorNotWellFormed = -32700,
    ParseErrorUnsupportedEncoding = -32701,
    ParseErrorInvalidCharacterForEncoding = -32702,
    ServerErrorInvalidXmlRpc = -32600,
    ServerErrorRequestedMethodNotFound = -32601,
    ServerErrorInvalidMethodParameters = -32602,
    ServerErrorInternalXmlRpcError = -32603,
    ApplicationError = -32500,
    SystemError = -32400,
    TransportError = -32300,
}
pub const SOUP_XMLRPC_FAULT_PARSE_ERROR_NOT_WELL_FORMED: SoupXMLRPCFault = SoupXMLRPCFault::ParseErrorNotWellFormed;
pub const SOUP_XMLRPC_FAULT_PARSE_ERROR_UNSUPPORTED_ENCODING: SoupXMLRPCFault = SoupXMLRPCFault::ParseErrorUnsupportedEncoding;
pub const SOUP_XMLRPC_FAULT_PARSE_ERROR_INVALID_CHARACTER_FOR_ENCODING: SoupXMLRPCFault = SoupXMLRPCFault::ParseErrorInvalidCharacterForEncoding;
pub const SOUP_XMLRPC_FAULT_SERVER_ERROR_INVALID_XML_RPC: SoupXMLRPCFault = SoupXMLRPCFault::ServerErrorInvalidXmlRpc;
pub const SOUP_XMLRPC_FAULT_SERVER_ERROR_REQUESTED_METHOD_NOT_FOUND: SoupXMLRPCFault = SoupXMLRPCFault::ServerErrorRequestedMethodNotFound;
pub const SOUP_XMLRPC_FAULT_SERVER_ERROR_INVALID_METHOD_PARAMETERS: SoupXMLRPCFault = SoupXMLRPCFault::ServerErrorInvalidMethodParameters;
pub const SOUP_XMLRPC_FAULT_SERVER_ERROR_INTERNAL_XML_RPC_ERROR: SoupXMLRPCFault = SoupXMLRPCFault::ServerErrorInternalXmlRpcError;
pub const SOUP_XMLRPC_FAULT_APPLICATION_ERROR: SoupXMLRPCFault = SoupXMLRPCFault::ApplicationError;
pub const SOUP_XMLRPC_FAULT_SYSTEM_ERROR: SoupXMLRPCFault = SoupXMLRPCFault::SystemError;
pub const SOUP_XMLRPC_FAULT_TRANSPORT_ERROR: SoupXMLRPCFault = SoupXMLRPCFault::TransportError;


pub const SOUP_ADDRESS_ANY_PORT: i32 = 0;
pub const SOUP_ADDRESS_FAMILY: &'static str = r##"family"##;
pub const SOUP_ADDRESS_NAME: &'static str = r##"name"##;
pub const SOUP_ADDRESS_PHYSICAL: &'static str = r##"physical"##;
pub const SOUP_ADDRESS_PORT: &'static str = r##"port"##;
pub const SOUP_ADDRESS_PROTOCOL: &'static str = r##"protocol"##;
pub const SOUP_ADDRESS_SOCKADDR: &'static str = r##"sockaddr"##;
pub const SOUP_AUTH_DOMAIN_ADD_PATH: &'static str = r##"add-path"##;
pub const SOUP_AUTH_DOMAIN_BASIC_AUTH_CALLBACK: &'static str = r##"auth-callback"##;
pub const SOUP_AUTH_DOMAIN_BASIC_AUTH_DATA: &'static str = r##"auth-data"##;
pub const SOUP_AUTH_DOMAIN_BASIC_H: i32 = 1;
pub const SOUP_AUTH_DOMAIN_DIGEST_AUTH_CALLBACK: &'static str = r##"auth-callback"##;
pub const SOUP_AUTH_DOMAIN_DIGEST_AUTH_DATA: &'static str = r##"auth-data"##;
pub const SOUP_AUTH_DOMAIN_DIGEST_H: i32 = 1;
pub const SOUP_AUTH_DOMAIN_FILTER: &'static str = r##"filter"##;
pub const SOUP_AUTH_DOMAIN_FILTER_DATA: &'static str = r##"filter-data"##;
pub const SOUP_AUTH_DOMAIN_GENERIC_AUTH_CALLBACK: &'static str = r##"generic-auth-callback"##;
pub const SOUP_AUTH_DOMAIN_GENERIC_AUTH_DATA: &'static str = r##"generic-auth-data"##;
pub const SOUP_AUTH_DOMAIN_H: i32 = 1;
pub const SOUP_AUTH_DOMAIN_PROXY: &'static str = r##"proxy"##;
pub const SOUP_AUTH_DOMAIN_REALM: &'static str = r##"realm"##;
pub const SOUP_AUTH_DOMAIN_REMOVE_PATH: &'static str = r##"remove-path"##;
pub const SOUP_AUTH_H: i32 = 1;
pub const SOUP_AUTH_HOST: &'static str = r##"host"##;
pub const SOUP_AUTH_IS_AUTHENTICATED: &'static str = r##"is-authenticated"##;
pub const SOUP_AUTH_IS_FOR_PROXY: &'static str = r##"is-for-proxy"##;
pub const SOUP_AUTH_MANAGER_H: i32 = 1;
pub const SOUP_AUTH_REALM: &'static str = r##"realm"##;
pub const SOUP_AUTH_SCHEME_NAME: &'static str = r##"scheme-name"##;
pub const SOUP_CACHE_H: i32 = 1;
pub const SOUP_CHAR_HTTP_CTL: i32 = 16;
pub const SOUP_CHAR_HTTP_SEPARATOR: i32 = 8;
pub const SOUP_CHAR_URI_GEN_DELIMS: i32 = 2;
pub const SOUP_CHAR_URI_PERCENT_ENCODED: i32 = 1;
pub const SOUP_CHAR_URI_SUB_DELIMS: i32 = 4;
pub const SOUP_CONTENT_DECODER_H: i32 = 1;
pub const SOUP_CONTENT_SNIFFER_H: i32 = 1;
pub const SOUP_COOKIE_H: i32 = 1;
pub const SOUP_COOKIE_JAR_ACCEPT_POLICY: &'static str = r##"accept-policy"##;
pub const SOUP_COOKIE_JAR_DB_FILENAME: &'static str = r##"filename"##;
pub const SOUP_COOKIE_JAR_DB_H: i32 = 1;
pub const SOUP_COOKIE_JAR_H: i32 = 1;
pub const SOUP_COOKIE_JAR_READ_ONLY: &'static str = r##"read-only"##;
pub const SOUP_COOKIE_JAR_TEXT_FILENAME: &'static str = r##"filename"##;
pub const SOUP_COOKIE_JAR_TEXT_H: i32 = 1;
pub const SOUP_COOKIE_MAX_AGE_ONE_DAY: i32 = 0;
pub const SOUP_COOKIE_MAX_AGE_ONE_HOUR: i32 = 3600;
pub const SOUP_COOKIE_MAX_AGE_ONE_WEEK: i32 = 0;
pub const SOUP_COOKIE_MAX_AGE_ONE_YEAR: i32 = 0;
pub const SOUP_DATE_H: i32 = 1;
pub const SOUP_FORM_H: i32 = 1;
pub const SOUP_FORM_MIME_TYPE_MULTIPART: &'static str = r##"multipart/form-data"##;
pub const SOUP_FORM_MIME_TYPE_URLENCODED: &'static str = r##"application/x-www-form-urlencoded"##;
pub const SOUP_HEADERS_H: i32 = 1;
pub const SOUP_LOGGER_H: i32 = 1;
pub const SOUP_MESSAGE_BODY_H: i32 = 1;
pub const SOUP_MESSAGE_FIRST_PARTY: &'static str = r##"first-party"##;
pub const SOUP_MESSAGE_FLAGS: &'static str = r##"flags"##;
pub const SOUP_MESSAGE_H: i32 = 1;
pub const SOUP_MESSAGE_HEADERS_H: i32 = 1;
pub const SOUP_MESSAGE_HTTP_VERSION: &'static str = r##"http-version"##;
pub const SOUP_MESSAGE_METHOD: &'static str = r##"method"##;
pub const SOUP_MESSAGE_PRIORITY: &'static str = r##"priority"##;
pub const SOUP_MESSAGE_REASON_PHRASE: &'static str = r##"reason-phrase"##;
pub const SOUP_MESSAGE_REQUEST_BODY: &'static str = r##"request-body"##;
pub const SOUP_MESSAGE_REQUEST_BODY_DATA: &'static str = r##"request-body-data"##;
pub const SOUP_MESSAGE_REQUEST_HEADERS: &'static str = r##"request-headers"##;
pub const SOUP_MESSAGE_RESPONSE_BODY: &'static str = r##"response-body"##;
pub const SOUP_MESSAGE_RESPONSE_BODY_DATA: &'static str = r##"response-body-data"##;
pub const SOUP_MESSAGE_RESPONSE_HEADERS: &'static str = r##"response-headers"##;
pub const SOUP_MESSAGE_SERVER_SIDE: &'static str = r##"server-side"##;
pub const SOUP_MESSAGE_STATUS_CODE: &'static str = r##"status-code"##;
pub const SOUP_MESSAGE_TLS_CERTIFICATE: &'static str = r##"tls-certificate"##;
pub const SOUP_MESSAGE_TLS_ERRORS: &'static str = r##"tls-errors"##;
pub const SOUP_MESSAGE_URI: &'static str = r##"uri"##;
pub const SOUP_METHOD_H: i32 = 1;
pub const SOUP_MISC_H: i32 = 1;
pub const SOUP_MULTIPART_H: i32 = 1;
pub const SOUP_MULTIPART_INPUT_STREAM_H: i32 = 1;
pub const SOUP_PASSWORD_MANAGER_H: i32 = 1;
pub const SOUP_PROXY_RESOLVER_DEFAULT_H: i32 = 1;
pub const SOUP_PROXY_URI_RESOLVER_H: i32 = 1;
pub const SOUP_REQUESTER_H: i32 = 1;
pub const SOUP_REQUEST_DATA_H: i32 = 1;
pub const SOUP_REQUEST_FILE_H: i32 = 1;
pub const SOUP_REQUEST_H: i32 = 1;
pub const SOUP_REQUEST_HTTP_H: i32 = 1;
pub const SOUP_REQUEST_SESSION: &'static str = r##"session"##;
pub const SOUP_REQUEST_URI: &'static str = r##"uri"##;
pub const SOUP_SERVER_ASYNC_CONTEXT: &'static str = r##"async-context"##;
pub const SOUP_SERVER_H: i32 = 1;
pub const SOUP_SERVER_HTTPS_ALIASES: &'static str = r##"https-aliases"##;
pub const SOUP_SERVER_HTTP_ALIASES: &'static str = r##"http-aliases"##;
pub const SOUP_SERVER_INTERFACE: &'static str = r##"interface"##;
pub const SOUP_SERVER_PORT: &'static str = r##"port"##;
pub const SOUP_SERVER_RAW_PATHS: &'static str = r##"raw-paths"##;
pub const SOUP_SERVER_SERVER_HEADER: &'static str = r##"server-header"##;
pub const SOUP_SERVER_SSL_CERT_FILE: &'static str = r##"ssl-cert-file"##;
pub const SOUP_SERVER_SSL_KEY_FILE: &'static str = r##"ssl-key-file"##;
pub const SOUP_SERVER_TLS_CERTIFICATE: &'static str = r##"tls-certificate"##;
pub const SOUP_SESSION_ACCEPT_LANGUAGE: &'static str = r##"accept-language"##;
pub const SOUP_SESSION_ACCEPT_LANGUAGE_AUTO: &'static str = r##"accept-language-auto"##;
pub const SOUP_SESSION_ADD_FEATURE: &'static str = r##"add-feature"##;
pub const SOUP_SESSION_ADD_FEATURE_BY_TYPE: &'static str = r##"add-feature-by-type"##;
pub const SOUP_SESSION_ASYNC_CONTEXT: &'static str = r##"async-context"##;
pub const SOUP_SESSION_ASYNC_H: i32 = 1;
pub const SOUP_SESSION_FEATURE_H: i32 = 1;
pub const SOUP_SESSION_H: i32 = 1;
pub const SOUP_SESSION_HTTPS_ALIASES: &'static str = r##"https-aliases"##;
pub const SOUP_SESSION_HTTP_ALIASES: &'static str = r##"http-aliases"##;
pub const SOUP_SESSION_IDLE_TIMEOUT: &'static str = r##"idle-timeout"##;
pub const SOUP_SESSION_LOCAL_ADDRESS: &'static str = r##"local-address"##;
pub const SOUP_SESSION_MAX_CONNS: &'static str = r##"max-conns"##;
pub const SOUP_SESSION_MAX_CONNS_PER_HOST: &'static str = r##"max-conns-per-host"##;
pub const SOUP_SESSION_PROXY_RESOLVER: &'static str = r##"proxy-resolver"##;
pub const SOUP_SESSION_PROXY_URI: &'static str = r##"proxy-uri"##;
pub const SOUP_SESSION_REMOVE_FEATURE_BY_TYPE: &'static str = r##"remove-feature-by-type"##;
pub const SOUP_SESSION_SSL_CA_FILE: &'static str = r##"ssl-ca-file"##;
pub const SOUP_SESSION_SSL_STRICT: &'static str = r##"ssl-strict"##;
pub const SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE: &'static str = r##"ssl-use-system-ca-file"##;
pub const SOUP_SESSION_SYNC_H: i32 = 1;
pub const SOUP_SESSION_TIMEOUT: &'static str = r##"timeout"##;
pub const SOUP_SESSION_TLS_DATABASE: &'static str = r##"tls-database"##;
pub const SOUP_SESSION_TLS_INTERACTION: &'static str = r##"tls-interaction"##;
pub const SOUP_SESSION_USER_AGENT: &'static str = r##"user-agent"##;
pub const SOUP_SESSION_USE_NTLM: &'static str = r##"use-ntlm"##;
pub const SOUP_SESSION_USE_THREAD_CONTEXT: &'static str = r##"use-thread-context"##;
pub const SOUP_SOCKET_ASYNC_CONTEXT: &'static str = r##"async-context"##;
pub const SOUP_SOCKET_FLAG_NONBLOCKING: &'static str = r##"non-blocking"##;
pub const SOUP_SOCKET_H: i32 = 1;
pub const SOUP_SOCKET_IS_SERVER: &'static str = r##"is-server"##;
pub const SOUP_SOCKET_LOCAL_ADDRESS: &'static str = r##"local-address"##;
pub const SOUP_SOCKET_REMOTE_ADDRESS: &'static str = r##"remote-address"##;
pub const SOUP_SOCKET_SSL_CREDENTIALS: &'static str = r##"ssl-creds"##;
pub const SOUP_SOCKET_SSL_FALLBACK: &'static str = r##"ssl-fallback"##;
pub const SOUP_SOCKET_SSL_STRICT: &'static str = r##"ssl-strict"##;
pub const SOUP_SOCKET_TIMEOUT: &'static str = r##"timeout"##;
pub const SOUP_SOCKET_TLS_CERTIFICATE: &'static str = r##"tls-certificate"##;
pub const SOUP_SOCKET_TLS_ERRORS: &'static str = r##"tls-errors"##;
pub const SOUP_SOCKET_TRUSTED_CERTIFICATE: &'static str = r##"trusted-certificate"##;
pub const SOUP_SOCKET_USE_THREAD_CONTEXT: &'static str = r##"use-thread-context"##;
pub const SOUP_STATUS_H: i32 = 1;
pub const SOUP_TYPES_H: i32 = 1;
pub const SOUP_URI_H: i32 = 1;
pub const SOUP_VALUE_UTILS_H: i32 = 1;
pub const SOUP_XMLRPC_H: i32 = 1;
pub const SOUP_XMLRPC_OLD_H: i32 = 1;

bitflags! {
    #[repr(C)]
    flags SoupCacheability: c_uint {
        const SOUP_CACHE_CACHEABLE = 1,
        const SOUP_CACHE_UNCACHEABLE = 2,
        const SOUP_CACHE_INVALIDATES = 4,
        const SOUP_CACHE_VALIDATES = 8,
    }
}

bitflags! {
    #[repr(C)]
    flags SoupExpectation: c_uint {
        const SOUP_EXPECTATION_UNRECOGNIZED = 1,
        const SOUP_EXPECTATION_CONTINUE = 2,
    }
}

bitflags! {
    #[repr(C)]
    flags SoupMessageFlags: c_uint {
        const SOUP_MESSAGE_NO_REDIRECT = 2,
        const SOUP_MESSAGE_CAN_REBUILD = 4,
        const SOUP_MESSAGE_OVERWRITE_CHUNKS = 8,
        const SOUP_MESSAGE_CONTENT_DECODED = 16,
        const SOUP_MESSAGE_CERTIFICATE_TRUSTED = 32,
        const SOUP_MESSAGE_NEW_CONNECTION = 64,
        const SOUP_MESSAGE_IDEMPOTENT = 128,
        const SOUP_MESSAGE_IGNORE_CONNECTION_LIMITS = 256,
    }
}

bitflags! {
    #[repr(C)]
    flags SoupServerListenOptions: c_uint {
        const SOUP_SERVER_LISTEN_HTTPS = 1,
        const SOUP_SERVER_LISTEN_IPV4_ONLY = 2,
        const SOUP_SERVER_LISTEN_IPV6_ONLY = 4,
    }
}



pub type SoupAddressCallback = Option<unsafe extern "C" fn(*mut SoupAddress, c_uint, gpointer)>;
pub type SoupAuthDomainBasicAuthCallback = Option<unsafe extern "C" fn(*mut SoupAuthDomain, *mut SoupMessage, *const c_char, *const c_char, gpointer) -> gboolean>;
pub type SoupAuthDomainDigestAuthCallback = Option<unsafe extern "C" fn(*mut SoupAuthDomain, *mut SoupMessage, *const c_char, gpointer) -> *mut c_char>;
pub type SoupAuthDomainFilter = Option<unsafe extern "C" fn(*mut SoupAuthDomain, *mut SoupMessage, gpointer) -> gboolean>;
pub type SoupAuthDomainGenericAuthCallback = Option<unsafe extern "C" fn(*mut SoupAuthDomain, *mut SoupMessage, *const c_char, gpointer) -> gboolean>;
pub type SoupChunkAllocator = Option<unsafe extern "C" fn(*mut SoupMessage, size_t, gpointer) -> *mut SoupBuffer>;
pub type SoupLoggerFilter = Option<unsafe extern "C" fn(*mut SoupLogger, *mut SoupMessage, gpointer) -> SoupLoggerLogLevel>;
pub type SoupLoggerPrinter = Option<unsafe extern "C" fn(*mut SoupLogger, SoupLoggerLogLevel, c_char, *const c_char, gpointer)>;
pub type SoupMessageHeadersForeachFunc = Option<unsafe extern "C" fn(*const c_char, *const c_char, gpointer)>;
pub type SoupPasswordManagerCallback = Option<unsafe extern "C" fn(*mut SoupPasswordManager, *mut SoupMessage, *mut SoupAuth, gboolean, gpointer)>;
pub type SoupProxyURIResolverCallback = Option<unsafe extern "C" fn(*mut SoupProxyURIResolver, c_uint, *mut SoupURI, gpointer)>;
pub type SoupServerCallback = Option<unsafe extern "C" fn(*mut SoupServer, *mut SoupMessage, *const c_char, *mut glib::GHashTable, *mut SoupClientContext, gpointer)>;
pub type SoupServerWebsocketCallback = Option<unsafe extern "C" fn(*mut SoupServer, *mut SoupWebsocketConnection, *const c_char, *mut SoupClientContext, gpointer)>;
pub type SoupSessionCallback = Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage, gpointer)>;
pub type SoupSocketCallback = Option<unsafe extern "C" fn(*mut SoupSocket, c_uint, gpointer)>;

#[repr(C)]
pub struct SoupAddressClass {
    pub parent_class: gobject::GObjectClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupAuthClass {
    pub parent_class: gobject::GObjectClass,
    pub scheme_name: *const c_char,
    pub strength: c_uint,
    pub update: Option<unsafe extern "C" fn(*mut SoupAuth, *mut SoupMessage, *mut glib::GHashTable) -> gboolean>,
    pub get_protection_space: Option<unsafe extern "C" fn(*mut SoupAuth, *mut SoupURI) -> *mut glib::GSList>,
    pub authenticate: Option<unsafe extern "C" fn(*mut SoupAuth, *const c_char, *const c_char)>,
    pub is_authenticated: Option<unsafe extern "C" fn(*mut SoupAuth) -> gboolean>,
    pub get_authorization: Option<unsafe extern "C" fn(*mut SoupAuth, *mut SoupMessage) -> *mut c_char>,
    pub is_ready: Option<unsafe extern "C" fn(*mut SoupAuth, *mut SoupMessage) -> gboolean>,
    pub can_authenticate: Option<unsafe extern "C" fn(*mut SoupAuth) -> gboolean>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupAuthDomainBasicClass {
    pub parent_class: SoupAuthDomainClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupAuthDomainClass {
    pub parent_class: gobject::GObjectClass,
    pub accepts: Option<unsafe extern "C" fn(*mut SoupAuthDomain, *mut SoupMessage, *const c_char) -> *mut c_char>,
    pub challenge: Option<unsafe extern "C" fn(*mut SoupAuthDomain, *mut SoupMessage) -> *mut c_char>,
    pub check_password: Option<unsafe extern "C" fn(*mut SoupAuthDomain, *mut SoupMessage, *const c_char, *const c_char) -> gboolean>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupAuthDomainDigestClass {
    pub parent_class: SoupAuthDomainClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupAuthManagerClass {
    pub parent_class: gobject::GObjectClass,
    pub authenticate: Option<unsafe extern "C" fn(*mut SoupAuthManager, *mut SoupMessage, *mut SoupAuth, gboolean)>,
}

#[repr(C)]
pub struct SoupAuthManagerPrivate(c_void);

#[repr(C)]
pub struct SoupBuffer {
   pub data: *mut c_char,
   pub length: size_t,
}

#[repr(C)]
pub struct SoupCacheClass {
    pub parent_class: gobject::GObjectClass,
    pub get_cacheability: Option<unsafe extern "C" fn(*mut SoupCache, *mut SoupMessage) -> SoupCacheability>,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupCachePrivate(c_void);

#[repr(C)]
pub struct SoupClientContext(c_void);

#[repr(C)]
pub struct SoupConnection(c_void);

#[repr(C)]
pub struct SoupContentDecoderClass {
    pub parent_class: gobject::GObjectClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupContentDecoderPrivate(c_void);

#[repr(C)]
pub struct SoupContentSnifferClass {
    pub parent_class: gobject::GObjectClass,
    pub sniff: Option<unsafe extern "C" fn(*mut SoupContentSniffer, *mut SoupMessage, *mut SoupBuffer, *mut *mut glib::GHashTable) -> *mut c_char>,
    pub get_buffer_size: Option<unsafe extern "C" fn(*mut SoupContentSniffer) -> size_t>,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved5: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupContentSnifferPrivate(c_void);

#[repr(C)]
pub struct SoupCookie {
    pub name: *mut c_char,
    pub value: *mut c_char,
    pub domain: *mut c_char,
    pub path: *mut c_char,
    pub expires: *mut SoupDate,
    pub secure: gboolean,
    pub http_only: gboolean,
}

#[repr(C)]
pub struct SoupCookieJarClass {
    pub parent_class: gobject::GObjectClass,
    pub save: Option<unsafe extern "C" fn(*mut SoupCookieJar)>,
    pub is_persistent: Option<unsafe extern "C" fn(*mut SoupCookieJar) -> gboolean>,
    pub changed: Option<unsafe extern "C" fn(*mut SoupCookieJar, *mut SoupCookie, *mut SoupCookie)>,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupCookieJarDBClass {
    pub parent_class: SoupCookieJarClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupCookieJarTextClass {
    pub parent_class: SoupCookieJarClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupDate {
    pub year: c_int,
    pub month: c_int,
    pub day: c_int,
    pub hour: c_int,
    pub minute: c_int,
    pub second: c_int,
    pub utc: gboolean,
    pub offset: c_int,
}

#[repr(C)]
pub struct SoupLoggerClass {
    pub parent_class: gobject::GObjectClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupMessageBody {
    pub data: *const c_char,
    pub length: i64,
}

#[repr(C)]
pub struct SoupMessageClass {
    pub parent_class: gobject::GObjectClass,
    pub wrote_informational: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub wrote_headers: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub wrote_chunk: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub wrote_body: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub got_informational: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub got_headers: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub got_chunk: Option<unsafe extern "C" fn(*mut SoupMessage, *mut SoupBuffer)>,
    pub got_body: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub restarted: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub finished: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub starting: Option<unsafe extern "C" fn(*mut SoupMessage)>,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupMessageHeaders(c_void);

#[repr(C)]
pub struct SoupMessageHeadersIter {
    dummy: [gpointer; 3],
}

#[repr(C)]
pub struct SoupMessageQueue(c_void);

#[repr(C)]
pub struct SoupMessageQueueItem(c_void);

#[repr(C)]
pub struct SoupMultipart(c_void);

#[repr(C)]
pub struct SoupMultipartInputStreamClass {
    pub parent_class: gio::GFilterInputStreamClass,
}

#[repr(C)]
pub struct SoupMultipartInputStreamPrivate(c_void);

#[repr(C)]
pub struct SoupPasswordManagerInterface {
    pub base: gobject::GTypeInterface,
    pub get_passwords_async: Option<unsafe extern "C" fn(*mut SoupPasswordManager, *mut SoupMessage, *mut SoupAuth, gboolean, *mut glib::GMainContext, *mut gio::GCancellable, SoupPasswordManagerCallback, gpointer)>,
    pub get_passwords_sync: Option<unsafe extern "C" fn(*mut SoupPasswordManager, *mut SoupMessage, *mut SoupAuth, *mut gio::GCancellable)>,
}

#[repr(C)]
pub struct SoupProxyResolverDefaultClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct SoupProxyURIResolverInterface {
    pub base: gobject::GTypeInterface,
    pub get_proxy_uri_async: Option<unsafe extern "C" fn(*mut SoupProxyURIResolver, *mut SoupURI, *mut glib::GMainContext, *mut gio::GCancellable, SoupProxyURIResolverCallback, gpointer)>,
    pub get_proxy_uri_sync: Option<unsafe extern "C" fn(*mut SoupProxyURIResolver, *mut SoupURI, *mut gio::GCancellable, *mut *mut SoupURI) -> c_uint>,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupRange {
    pub start: i64,
    pub end: i64,
}

#[repr(C)]
pub struct SoupRequestClass {
    pub parent: gobject::GObjectClass,
    pub schemes: *mut *const c_char,
    pub check_uri: Option<unsafe extern "C" fn(*mut SoupRequest, *mut SoupURI, *mut *mut glib::GError) -> gboolean>,
    pub send: Option<unsafe extern "C" fn(*mut SoupRequest, *mut gio::GCancellable, *mut *mut glib::GError) -> *mut gio::GInputStream>,
    pub send_async: Option<unsafe extern "C" fn(*mut SoupRequest, *mut gio::GCancellable, gio::GAsyncReadyCallback, gpointer)>,
    pub send_finish: Option<unsafe extern "C" fn(*mut SoupRequest, *mut gio::GAsyncResult, *mut *mut glib::GError) -> *mut gio::GInputStream>,
    pub get_content_length: Option<unsafe extern "C" fn(*mut SoupRequest) -> i64>,
    pub get_content_type: Option<unsafe extern "C" fn(*mut SoupRequest) -> *const c_char>,
}

#[repr(C)]
pub struct SoupRequestDataClass {
    pub parent: SoupRequestClass,
}

#[repr(C)]
pub struct SoupRequestDataPrivate(c_void);

#[repr(C)]
pub struct SoupRequestFileClass {
    pub parent: SoupRequestClass,
}

#[repr(C)]
pub struct SoupRequestFilePrivate(c_void);

#[repr(C)]
pub struct SoupRequestHTTPClass {
    pub parent: SoupRequestClass,
}

#[repr(C)]
pub struct SoupRequestHTTPPrivate(c_void);

#[repr(C)]
pub struct SoupRequestPrivate(c_void);

#[repr(C)]
pub struct SoupRequesterClass {
    pub parent_class: gobject::GObjectClass,
}

#[repr(C)]
pub struct SoupRequesterPrivate(c_void);

#[repr(C)]
pub struct SoupServerClass {
    pub parent_class: gobject::GObjectClass,
    pub request_started: Option<unsafe extern "C" fn(*mut SoupServer, *mut SoupMessage, *mut SoupClientContext)>,
    pub request_read: Option<unsafe extern "C" fn(*mut SoupServer, *mut SoupMessage, *mut SoupClientContext)>,
    pub request_finished: Option<unsafe extern "C" fn(*mut SoupServer, *mut SoupMessage, *mut SoupClientContext)>,
    pub request_aborted: Option<unsafe extern "C" fn(*mut SoupServer, *mut SoupMessage, *mut SoupClientContext)>,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupSessionAsyncClass {
    pub parent_class: SoupSessionClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupSessionClass {
    pub parent_class: gobject::GObjectClass,
    pub request_started: Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage, *mut SoupSocket)>,
    pub authenticate: Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage, *mut SoupAuth, gboolean)>,
    pub queue_message: Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage, SoupSessionCallback, gpointer)>,
    pub requeue_message: Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage)>,
    pub send_message: Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage) -> c_uint>,
    pub cancel_message: Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage, c_uint)>,
    pub auth_required: Option<unsafe extern "C" fn(*mut SoupSession, *mut SoupMessage, *mut SoupAuth, gboolean)>,
    pub flush_queue: Option<unsafe extern "C" fn(*mut SoupSession)>,
    pub kick: Option<unsafe extern "C" fn(*mut SoupSession)>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupSessionFeatureInterface {
    pub parent: gobject::GTypeInterface,
    pub attach: Option<unsafe extern "C" fn(*mut SoupSessionFeature, *mut SoupSession)>,
    pub detach: Option<unsafe extern "C" fn(*mut SoupSessionFeature, *mut SoupSession)>,
    pub request_queued: Option<unsafe extern "C" fn(*mut SoupSessionFeature, *mut SoupSession, *mut SoupMessage)>,
    pub request_started: Option<unsafe extern "C" fn(*mut SoupSessionFeature, *mut SoupSession, *mut SoupMessage, *mut SoupSocket)>,
    pub request_unqueued: Option<unsafe extern "C" fn(*mut SoupSessionFeature, *mut SoupSession, *mut SoupMessage)>,
    pub add_feature: Option<unsafe extern "C" fn(*mut SoupSessionFeature, GType) -> gboolean>,
    pub remove_feature: Option<unsafe extern "C" fn(*mut SoupSessionFeature, GType) -> gboolean>,
    pub has_feature: Option<unsafe extern "C" fn(*mut SoupSessionFeature, GType) -> gboolean>,
}

#[repr(C)]
pub struct SoupSessionSyncClass {
    pub parent_class: SoupSessionClass,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupSocketClass {
    pub parent_class: gobject::GObjectClass,
    pub readable: Option<unsafe extern "C" fn(*mut SoupSocket)>,
    pub writable: Option<unsafe extern "C" fn(*mut SoupSocket)>,
    pub disconnected: Option<unsafe extern "C" fn(*mut SoupSocket)>,
    pub new_connection: Option<unsafe extern "C" fn(*mut SoupSocket, *mut SoupSocket)>,
    pub _libsoup_reserved1: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved2: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved3: Option<unsafe extern "C" fn()>,
    pub _libsoup_reserved4: Option<unsafe extern "C" fn()>,
}

#[repr(C)]
pub struct SoupURI {
    pub scheme: *const c_char,
    pub user: *mut c_char,
    pub password: *mut c_char,
    pub host: *mut c_char,
    pub port: c_uint,
    pub path: *mut c_char,
    pub query: *mut c_char,
    pub fragment: *mut c_char,
}

#[repr(C)]
pub struct SoupWebsocketConnectionClass {
    pub parent: gobject::GObjectClass,
    pub message: Option<unsafe extern "C" fn(*mut SoupWebsocketConnection, SoupWebsocketDataType, *mut glib::GBytes)>,
    pub error: Option<unsafe extern "C" fn(*mut SoupWebsocketConnection, *mut glib::GError)>,
    pub closing: Option<unsafe extern "C" fn(*mut SoupWebsocketConnection)>,
    pub closed: Option<unsafe extern "C" fn(*mut SoupWebsocketConnection)>,
}

#[repr(C)]
pub struct SoupWebsocketConnectionPrivate(c_void);

#[repr(C)]
pub struct SoupXMLRPCParams(c_void);


#[repr(C)]
pub struct SoupAddress(c_void);
#[repr(C)]
pub struct SoupAuth(c_void);
#[repr(C)]
pub struct SoupAuthBasic(c_void);
#[repr(C)]
pub struct SoupAuthDigest(c_void);
#[repr(C)]
pub struct SoupAuthDomain(c_void);
#[repr(C)]
pub struct SoupAuthDomainBasic(c_void);
#[repr(C)]
pub struct SoupAuthDomainDigest(c_void);
#[repr(C)]
pub struct SoupAuthManager(c_void);
#[repr(C)]
pub struct SoupAuthNTLM(c_void);
#[repr(C)]
pub struct SoupAuthNegotiate(c_void);
#[repr(C)]
pub struct SoupCache(c_void);
#[repr(C)]
pub struct SoupContentDecoder(c_void);
#[repr(C)]
pub struct SoupContentSniffer(c_void);
#[repr(C)]
pub struct SoupCookieJar(c_void);
#[repr(C)]
pub struct SoupCookieJarDB(c_void);
#[repr(C)]
pub struct SoupCookieJarText(c_void);
#[repr(C)]
pub struct SoupLogger(c_void);
#[repr(C)]
pub struct SoupMessage(c_void);
#[repr(C)]
pub struct SoupMultipartInputStream(c_void);
#[repr(C)]
pub struct SoupProxyResolverDefault(c_void);
#[repr(C)]
pub struct SoupRequest(c_void);
#[repr(C)]
pub struct SoupRequestData(c_void);
#[repr(C)]
pub struct SoupRequestFile(c_void);
#[repr(C)]
pub struct SoupRequestHTTP(c_void);
#[repr(C)]
pub struct SoupRequester(c_void);
#[repr(C)]
pub struct SoupServer(c_void);
#[repr(C)]
pub struct SoupSession(c_void);
#[repr(C)]
pub struct SoupSessionAsync(c_void);
#[repr(C)]
pub struct SoupSessionSync(c_void);
#[repr(C)]
pub struct SoupSocket(c_void);
#[repr(C)]
pub struct SoupWebsocketConnection(c_void);

#[repr(C)]
pub struct SoupPasswordManager(c_void);
#[repr(C)]
pub struct SoupProxyURIResolver(c_void);
#[repr(C)]
pub struct SoupSessionFeature(c_void);

extern "C" {

    //=========================================================================
    // SoupRequestError
    //=========================================================================
    pub fn soup_request_error_quark() -> glib::GQuark;

    //=========================================================================
    // SoupRequesterError
    //=========================================================================
    pub fn soup_requester_error_quark() -> glib::GQuark;

    //=========================================================================
    // SoupStatus
    //=========================================================================
    pub fn soup_status_get_phrase(status_code: c_uint) -> *const c_char;
    #[cfg(feature = "v2_26")]
    pub fn soup_status_proxify(status_code: c_uint) -> c_uint;

    //=========================================================================
    // SoupTLDError
    //=========================================================================
    pub fn soup_tld_error_quark() -> glib::GQuark;

    //=========================================================================
    // SoupWebsocketError
    //=========================================================================
    pub fn soup_websocket_error_get_quark() -> glib::GQuark;

    //=========================================================================
    // SoupXMLRPCError
    //=========================================================================
    pub fn soup_xmlrpc_error_quark() -> glib::GQuark;

    //=========================================================================
    // SoupXMLRPCFault
    //=========================================================================
    pub fn soup_xmlrpc_fault_quark() -> glib::GQuark;

    //=========================================================================
    // SoupBuffer
    //=========================================================================
    pub fn soup_buffer_get_type() -> GType;
    pub fn soup_buffer_new(use_: SoupMemoryUse, data: gconstpointer, length: size_t) -> *mut SoupBuffer;
    #[cfg(feature = "v2_32")]
    pub fn soup_buffer_new_take(data: *mut u8, length: size_t) -> *mut SoupBuffer;
    pub fn soup_buffer_new_with_owner(data: gconstpointer, length: size_t, owner: gpointer, owner_dnotify: glib::GDestroyNotify) -> *mut SoupBuffer;
    pub fn soup_buffer_copy(buffer: *mut SoupBuffer) -> *mut SoupBuffer;
    pub fn soup_buffer_free(buffer: *mut SoupBuffer);
    #[cfg(feature = "v2_40")]
    pub fn soup_buffer_get_as_bytes(buffer: *mut SoupBuffer) -> *mut glib::GBytes;
    #[cfg(feature = "v2_32")]
    pub fn soup_buffer_get_data(buffer: *mut SoupBuffer, data: *mut *mut u8, length: *mut size_t);
    pub fn soup_buffer_get_owner(buffer: *mut SoupBuffer) -> gpointer;
    pub fn soup_buffer_new_subbuffer(parent: *mut SoupBuffer, offset: size_t, length: size_t) -> *mut SoupBuffer;

    //=========================================================================
    // SoupClientContext
    //=========================================================================
    pub fn soup_client_context_get_type() -> GType;
    pub fn soup_client_context_get_address(client: *mut SoupClientContext) -> *mut SoupAddress;
    pub fn soup_client_context_get_auth_domain(client: *mut SoupClientContext) -> *mut SoupAuthDomain;
    pub fn soup_client_context_get_auth_user(client: *mut SoupClientContext) -> *const c_char;
    #[cfg(feature = "v2_48")]
    pub fn soup_client_context_get_gsocket(client: *mut SoupClientContext) -> *mut gio::GSocket;
    pub fn soup_client_context_get_host(client: *mut SoupClientContext) -> *const c_char;
    #[cfg(feature = "v2_48")]
    pub fn soup_client_context_get_local_address(client: *mut SoupClientContext) -> *mut gio::GSocketAddress;
    #[cfg(feature = "v2_48")]
    pub fn soup_client_context_get_remote_address(client: *mut SoupClientContext) -> *mut gio::GSocketAddress;
    pub fn soup_client_context_get_socket(client: *mut SoupClientContext) -> *mut SoupSocket;
    #[cfg(feature = "v2_50")]
    pub fn soup_client_context_steal_connection(client: *mut SoupClientContext) -> *mut gio::GIOStream;

    //=========================================================================
    // SoupCookie
    //=========================================================================
    pub fn soup_cookie_get_type() -> GType;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_new(name: *const c_char, value: *const c_char, domain: *const c_char, path: *const c_char, max_age: c_int) -> *mut SoupCookie;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_applies_to_uri(cookie: *mut SoupCookie, uri: *mut SoupURI) -> gboolean;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_copy(cookie: *mut SoupCookie) -> *mut SoupCookie;
    #[cfg(feature = "v2_30")]
    pub fn soup_cookie_domain_matches(cookie: *mut SoupCookie, host: *const c_char) -> gboolean;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_equal(cookie1: *mut SoupCookie, cookie2: *mut SoupCookie) -> gboolean;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_free(cookie: *mut SoupCookie);
    #[cfg(feature = "v2_32")]
    pub fn soup_cookie_get_domain(cookie: *mut SoupCookie) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_cookie_get_expires(cookie: *mut SoupCookie) -> *mut SoupDate;
    #[cfg(feature = "v2_32")]
    pub fn soup_cookie_get_http_only(cookie: *mut SoupCookie) -> gboolean;
    #[cfg(feature = "v2_32")]
    pub fn soup_cookie_get_name(cookie: *mut SoupCookie) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_cookie_get_path(cookie: *mut SoupCookie) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_cookie_get_secure(cookie: *mut SoupCookie) -> gboolean;
    #[cfg(feature = "v2_32")]
    pub fn soup_cookie_get_value(cookie: *mut SoupCookie) -> *const c_char;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_domain(cookie: *mut SoupCookie, domain: *const c_char);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_expires(cookie: *mut SoupCookie, expires: *mut SoupDate);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_http_only(cookie: *mut SoupCookie, http_only: gboolean);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_max_age(cookie: *mut SoupCookie, max_age: c_int);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_name(cookie: *mut SoupCookie, name: *const c_char);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_path(cookie: *mut SoupCookie, path: *const c_char);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_secure(cookie: *mut SoupCookie, secure: gboolean);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_set_value(cookie: *mut SoupCookie, value: *const c_char);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_to_cookie_header(cookie: *mut SoupCookie) -> *mut c_char;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_to_set_cookie_header(cookie: *mut SoupCookie) -> *mut c_char;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_parse(header: *const c_char, origin: *mut SoupURI) -> *mut SoupCookie;

    //=========================================================================
    // SoupDate
    //=========================================================================
    pub fn soup_date_get_type() -> GType;
    pub fn soup_date_new(year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, second: c_int) -> *mut SoupDate;
    pub fn soup_date_new_from_now(offset_seconds: c_int) -> *mut SoupDate;
    pub fn soup_date_new_from_string(date_string: *const c_char) -> *mut SoupDate;
    pub fn soup_date_new_from_time_t(when: c_long) -> *mut SoupDate;
    #[cfg(feature = "v2_24")]
    pub fn soup_date_copy(date: *mut SoupDate) -> *mut SoupDate;
    #[cfg(feature = "v2_24")]
    pub fn soup_date_free(date: *mut SoupDate);
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_day(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_hour(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_minute(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_month(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_offset(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_second(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_utc(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_32")]
    pub fn soup_date_get_year(date: *mut SoupDate) -> c_int;
    #[cfg(feature = "v2_24")]
    pub fn soup_date_is_past(date: *mut SoupDate) -> gboolean;
    pub fn soup_date_to_string(date: *mut SoupDate, format: SoupDateFormat) -> *mut c_char;
    pub fn soup_date_to_time_t(date: *mut SoupDate) -> c_long;
    #[cfg(feature = "v2_24")]
    pub fn soup_date_to_timeval(date: *mut SoupDate, time: *mut glib::GTimeVal);

    //=========================================================================
    // SoupMessageBody
    //=========================================================================
    pub fn soup_message_body_get_type() -> GType;
    pub fn soup_message_body_new() -> *mut SoupMessageBody;
    pub fn soup_message_body_append(body: *mut SoupMessageBody, use_: SoupMemoryUse, data: gconstpointer, length: size_t);
    pub fn soup_message_body_append_buffer(body: *mut SoupMessageBody, buffer: *mut SoupBuffer);
    #[cfg(feature = "v2_32")]
    pub fn soup_message_body_append_take(body: *mut SoupMessageBody, data: *mut u8, length: size_t);
    pub fn soup_message_body_complete(body: *mut SoupMessageBody);
    pub fn soup_message_body_flatten(body: *mut SoupMessageBody) -> *mut SoupBuffer;
    pub fn soup_message_body_free(body: *mut SoupMessageBody);
    #[cfg(feature = "v2_24")]
    pub fn soup_message_body_get_accumulate(body: *mut SoupMessageBody) -> gboolean;
    pub fn soup_message_body_get_chunk(body: *mut SoupMessageBody, offset: i64) -> *mut SoupBuffer;
    #[cfg(feature = "v2_24")]
    pub fn soup_message_body_got_chunk(body: *mut SoupMessageBody, chunk: *mut SoupBuffer);
    #[cfg(feature = "v2_24")]
    pub fn soup_message_body_set_accumulate(body: *mut SoupMessageBody, accumulate: gboolean);
    pub fn soup_message_body_truncate(body: *mut SoupMessageBody);
    #[cfg(feature = "v2_24")]
    pub fn soup_message_body_wrote_chunk(body: *mut SoupMessageBody, chunk: *mut SoupBuffer);

    //=========================================================================
    // SoupMessageHeaders
    //=========================================================================
    pub fn soup_message_headers_get_type() -> GType;
    pub fn soup_message_headers_new(type_: SoupMessageHeadersType) -> *mut SoupMessageHeaders;
    pub fn soup_message_headers_append(hdrs: *mut SoupMessageHeaders, name: *const c_char, value: *const c_char);
    #[cfg(feature = "v2_36")]
    pub fn soup_message_headers_clean_connection_headers(hdrs: *mut SoupMessageHeaders);
    pub fn soup_message_headers_clear(hdrs: *mut SoupMessageHeaders);
    pub fn soup_message_headers_foreach(hdrs: *mut SoupMessageHeaders, func: SoupMessageHeadersForeachFunc, user_data: gpointer);
    pub fn soup_message_headers_free(hdrs: *mut SoupMessageHeaders);
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_free_ranges(hdrs: *mut SoupMessageHeaders, ranges: *mut SoupRange);
    pub fn soup_message_headers_get(hdrs: *mut SoupMessageHeaders, name: *const c_char) -> *const c_char;
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_get_content_disposition(hdrs: *mut SoupMessageHeaders, disposition: *mut *mut c_char, params: *mut *mut glib::GHashTable) -> gboolean;
    pub fn soup_message_headers_get_content_length(hdrs: *mut SoupMessageHeaders) -> i64;
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_get_content_range(hdrs: *mut SoupMessageHeaders, start: *mut i64, end: *mut i64, total_length: *mut i64) -> gboolean;
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_get_content_type(hdrs: *mut SoupMessageHeaders, params: *mut *mut glib::GHashTable) -> *const c_char;
    pub fn soup_message_headers_get_encoding(hdrs: *mut SoupMessageHeaders) -> SoupEncoding;
    pub fn soup_message_headers_get_expectations(hdrs: *mut SoupMessageHeaders) -> SoupExpectation;
    #[cfg(feature = "v2_50")]
    pub fn soup_message_headers_get_headers_type(hdrs: *mut SoupMessageHeaders) -> SoupMessageHeadersType;
    #[cfg(feature = "v2_28")]
    pub fn soup_message_headers_get_list(hdrs: *mut SoupMessageHeaders, name: *const c_char) -> *const c_char;
    #[cfg(feature = "v2_28")]
    pub fn soup_message_headers_get_one(hdrs: *mut SoupMessageHeaders, name: *const c_char) -> *const c_char;
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_get_ranges(hdrs: *mut SoupMessageHeaders, total_length: i64, ranges: *mut *mut SoupRange, length: *mut c_int) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn soup_message_headers_header_contains(hdrs: *mut SoupMessageHeaders, name: *const c_char, token: *const c_char) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn soup_message_headers_header_equals(hdrs: *mut SoupMessageHeaders, name: *const c_char, value: *const c_char) -> gboolean;
    pub fn soup_message_headers_remove(hdrs: *mut SoupMessageHeaders, name: *const c_char);
    pub fn soup_message_headers_replace(hdrs: *mut SoupMessageHeaders, name: *const c_char, value: *const c_char);
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_set_content_disposition(hdrs: *mut SoupMessageHeaders, disposition: *const c_char, params: *mut glib::GHashTable);
    pub fn soup_message_headers_set_content_length(hdrs: *mut SoupMessageHeaders, content_length: i64);
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_set_content_range(hdrs: *mut SoupMessageHeaders, start: i64, end: i64, total_length: i64);
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_set_content_type(hdrs: *mut SoupMessageHeaders, content_type: *const c_char, params: *mut glib::GHashTable);
    pub fn soup_message_headers_set_encoding(hdrs: *mut SoupMessageHeaders, encoding: SoupEncoding);
    pub fn soup_message_headers_set_expectations(hdrs: *mut SoupMessageHeaders, expectations: SoupExpectation);
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_set_range(hdrs: *mut SoupMessageHeaders, start: i64, end: i64);
    #[cfg(feature = "v2_26")]
    pub fn soup_message_headers_set_ranges(hdrs: *mut SoupMessageHeaders, ranges: *mut SoupRange, length: c_int);

    //=========================================================================
    // SoupMessageHeadersIter
    //=========================================================================
    pub fn soup_message_headers_iter_next(iter: *mut SoupMessageHeadersIter, name: *mut *const c_char, value: *mut *const c_char) -> gboolean;
    pub fn soup_message_headers_iter_init(iter: *mut SoupMessageHeadersIter, hdrs: *mut SoupMessageHeaders);

    //=========================================================================
    // SoupMultipart
    //=========================================================================
    pub fn soup_multipart_get_type() -> GType;
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_new(mime_type: *const c_char) -> *mut SoupMultipart;
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_new_from_message(headers: *mut SoupMessageHeaders, body: *mut SoupMessageBody) -> *mut SoupMultipart;
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_append_form_file(multipart: *mut SoupMultipart, control_name: *const c_char, filename: *const c_char, content_type: *const c_char, body: *mut SoupBuffer);
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_append_form_string(multipart: *mut SoupMultipart, control_name: *const c_char, data: *const c_char);
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_append_part(multipart: *mut SoupMultipart, headers: *mut SoupMessageHeaders, body: *mut SoupBuffer);
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_free(multipart: *mut SoupMultipart);
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_get_length(multipart: *mut SoupMultipart) -> c_int;
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_get_part(multipart: *mut SoupMultipart, part: c_int, headers: *mut *mut SoupMessageHeaders, body: *mut *mut SoupBuffer) -> gboolean;
    #[cfg(feature = "v2_26")]
    pub fn soup_multipart_to_message(multipart: *mut SoupMultipart, dest_headers: *mut SoupMessageHeaders, dest_body: *mut SoupMessageBody);

    //=========================================================================
    // SoupURI
    //=========================================================================
    pub fn soup_uri_get_type() -> GType;
    pub fn soup_uri_new(uri_string: *const c_char) -> *mut SoupURI;
    pub fn soup_uri_copy(uri: *mut SoupURI) -> *mut SoupURI;
    #[cfg(feature = "v2_28")]
    pub fn soup_uri_copy_host(uri: *mut SoupURI) -> *mut SoupURI;
    pub fn soup_uri_equal(uri1: *mut SoupURI, uri2: *mut SoupURI) -> gboolean;
    pub fn soup_uri_free(uri: *mut SoupURI);
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_fragment(uri: *mut SoupURI) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_host(uri: *mut SoupURI) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_password(uri: *mut SoupURI) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_path(uri: *mut SoupURI) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_port(uri: *mut SoupURI) -> c_uint;
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_query(uri: *mut SoupURI) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_scheme(uri: *mut SoupURI) -> *const c_char;
    #[cfg(feature = "v2_32")]
    pub fn soup_uri_get_user(uri: *mut SoupURI) -> *const c_char;
    #[cfg(feature = "v2_28")]
    pub fn soup_uri_host_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    #[cfg(feature = "v2_28")]
    pub fn soup_uri_host_hash(key: gconstpointer) -> c_uint;
    pub fn soup_uri_new_with_base(base: *mut SoupURI, uri_string: *const c_char) -> *mut SoupURI;
    pub fn soup_uri_set_fragment(uri: *mut SoupURI, fragment: *const c_char);
    pub fn soup_uri_set_host(uri: *mut SoupURI, host: *const c_char);
    pub fn soup_uri_set_password(uri: *mut SoupURI, password: *const c_char);
    pub fn soup_uri_set_path(uri: *mut SoupURI, path: *const c_char);
    pub fn soup_uri_set_port(uri: *mut SoupURI, port: c_uint);
    pub fn soup_uri_set_query(uri: *mut SoupURI, query: *const c_char);
    pub fn soup_uri_set_query_from_fields(uri: *mut SoupURI, first_field: *const c_char, ...);
    pub fn soup_uri_set_query_from_form(uri: *mut SoupURI, form: *mut glib::GHashTable);
    pub fn soup_uri_set_scheme(uri: *mut SoupURI, scheme: *const c_char);
    pub fn soup_uri_set_user(uri: *mut SoupURI, user: *const c_char);
    pub fn soup_uri_to_string(uri: *mut SoupURI, just_path_and_query: gboolean) -> *mut c_char;
    pub fn soup_uri_uses_default_port(uri: *mut SoupURI) -> gboolean;
    pub fn soup_uri_decode(part: *const c_char) -> *mut c_char;
    pub fn soup_uri_encode(part: *const c_char, escape_extra: *const c_char) -> *mut c_char;
    pub fn soup_uri_normalize(part: *const c_char, unescape_extra: *const c_char) -> *mut c_char;

    //=========================================================================
    // SoupXMLRPCParams
    //=========================================================================
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_params_free(self_: *mut SoupXMLRPCParams);
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_params_parse(self_: *mut SoupXMLRPCParams, signature: *const c_char, error: *mut *mut glib::GError) -> *mut glib::GVariant;

    //=========================================================================
    // SoupAddress
    //=========================================================================
    pub fn soup_address_get_type() -> GType;
    pub fn soup_address_new(name: *const c_char, port: c_uint) -> *mut SoupAddress;
    pub fn soup_address_new_any(family: SoupAddressFamily, port: c_uint) -> *mut SoupAddress;
    pub fn soup_address_new_from_sockaddr(sa: *mut sockaddr, len: c_int) -> *mut SoupAddress;
    #[cfg(feature = "v2_26")]
    pub fn soup_address_equal_by_ip(addr1: gconstpointer, addr2: gconstpointer) -> gboolean;
    #[cfg(feature = "v2_26")]
    pub fn soup_address_equal_by_name(addr1: gconstpointer, addr2: gconstpointer) -> gboolean;
    #[cfg(feature = "v2_32")]
    pub fn soup_address_get_gsockaddr(addr: *mut SoupAddress) -> *mut gio::GSocketAddress;
    pub fn soup_address_get_name(addr: *mut SoupAddress) -> *const c_char;
    pub fn soup_address_get_physical(addr: *mut SoupAddress) -> *const c_char;
    pub fn soup_address_get_port(addr: *mut SoupAddress) -> c_uint;
    pub fn soup_address_get_sockaddr(addr: *mut SoupAddress, len: *mut c_int) -> *mut sockaddr;
    #[cfg(feature = "v2_26")]
    pub fn soup_address_hash_by_ip(addr: gconstpointer) -> c_uint;
    #[cfg(feature = "v2_26")]
    pub fn soup_address_hash_by_name(addr: gconstpointer) -> c_uint;
    pub fn soup_address_is_resolved(addr: *mut SoupAddress) -> gboolean;
    pub fn soup_address_resolve_async(addr: *mut SoupAddress, async_context: *mut glib::GMainContext, cancellable: *mut gio::GCancellable, callback: SoupAddressCallback, user_data: gpointer);
    pub fn soup_address_resolve_sync(addr: *mut SoupAddress, cancellable: *mut gio::GCancellable) -> c_uint;

    //=========================================================================
    // SoupAuth
    //=========================================================================
    pub fn soup_auth_get_type() -> GType;
    pub fn soup_auth_new(type_: GType, msg: *mut SoupMessage, auth_header: *const c_char) -> *mut SoupAuth;
    pub fn soup_auth_authenticate(auth: *mut SoupAuth, username: *const c_char, password: *const c_char);
    #[cfg(feature = "v2_54")]
    pub fn soup_auth_can_authenticate(auth: *mut SoupAuth) -> gboolean;
    pub fn soup_auth_free_protection_space(auth: *mut SoupAuth, space: *mut glib::GSList);
    pub fn soup_auth_get_authorization(auth: *mut SoupAuth, msg: *mut SoupMessage) -> *mut c_char;
    pub fn soup_auth_get_host(auth: *mut SoupAuth) -> *const c_char;
    pub fn soup_auth_get_info(auth: *mut SoupAuth) -> *mut c_char;
    pub fn soup_auth_get_protection_space(auth: *mut SoupAuth, source_uri: *mut SoupURI) -> *mut glib::GSList;
    pub fn soup_auth_get_realm(auth: *mut SoupAuth) -> *const c_char;
    pub fn soup_auth_get_saved_password(auth: *mut SoupAuth, user: *const c_char) -> *const c_char;
    pub fn soup_auth_get_saved_users(auth: *mut SoupAuth) -> *mut glib::GSList;
    pub fn soup_auth_get_scheme_name(auth: *mut SoupAuth) -> *const c_char;
    pub fn soup_auth_has_saved_password(auth: *mut SoupAuth, username: *const c_char, password: *const c_char);
    pub fn soup_auth_is_authenticated(auth: *mut SoupAuth) -> gboolean;
    pub fn soup_auth_is_for_proxy(auth: *mut SoupAuth) -> gboolean;
    #[cfg(feature = "v2_42")]
    pub fn soup_auth_is_ready(auth: *mut SoupAuth, msg: *mut SoupMessage) -> gboolean;
    pub fn soup_auth_save_password(auth: *mut SoupAuth, username: *const c_char, password: *const c_char);
    pub fn soup_auth_update(auth: *mut SoupAuth, msg: *mut SoupMessage, auth_header: *const c_char) -> gboolean;

    //=========================================================================
    // SoupAuthBasic
    //=========================================================================
    pub fn soup_auth_basic_get_type() -> GType;

    //=========================================================================
    // SoupAuthDigest
    //=========================================================================
    pub fn soup_auth_digest_get_type() -> GType;

    //=========================================================================
    // SoupAuthDomain
    //=========================================================================
    pub fn soup_auth_domain_get_type() -> GType;
    pub fn soup_auth_domain_accepts(domain: *mut SoupAuthDomain, msg: *mut SoupMessage) -> *mut c_char;
    pub fn soup_auth_domain_add_path(domain: *mut SoupAuthDomain, path: *const c_char);
    pub fn soup_auth_domain_basic_set_auth_callback(domain: *mut SoupAuthDomain, callback: SoupAuthDomainBasicAuthCallback, user_data: gpointer, dnotify: glib::GDestroyNotify);
    pub fn soup_auth_domain_challenge(domain: *mut SoupAuthDomain, msg: *mut SoupMessage);
    pub fn soup_auth_domain_check_password(domain: *mut SoupAuthDomain, msg: *mut SoupMessage, username: *const c_char, password: *const c_char) -> gboolean;
    pub fn soup_auth_domain_covers(domain: *mut SoupAuthDomain, msg: *mut SoupMessage) -> gboolean;
    pub fn soup_auth_domain_digest_set_auth_callback(domain: *mut SoupAuthDomain, callback: SoupAuthDomainDigestAuthCallback, user_data: gpointer, dnotify: glib::GDestroyNotify);
    pub fn soup_auth_domain_get_realm(domain: *mut SoupAuthDomain) -> *const c_char;
    pub fn soup_auth_domain_remove_path(domain: *mut SoupAuthDomain, path: *const c_char);
    pub fn soup_auth_domain_set_filter(domain: *mut SoupAuthDomain, filter: SoupAuthDomainFilter, filter_data: gpointer, dnotify: glib::GDestroyNotify);
    pub fn soup_auth_domain_set_generic_auth_callback(domain: *mut SoupAuthDomain, auth_callback: SoupAuthDomainGenericAuthCallback, auth_data: gpointer, dnotify: glib::GDestroyNotify);
    pub fn soup_auth_domain_try_generic_auth_callback(domain: *mut SoupAuthDomain, msg: *mut SoupMessage, username: *const c_char) -> gboolean;

    //=========================================================================
    // SoupAuthDomainBasic
    //=========================================================================
    pub fn soup_auth_domain_basic_get_type() -> GType;
    pub fn soup_auth_domain_basic_new(optname1: *const c_char, ...) -> *mut SoupAuthDomain;

    //=========================================================================
    // SoupAuthDomainDigest
    //=========================================================================
    pub fn soup_auth_domain_digest_get_type() -> GType;
    pub fn soup_auth_domain_digest_new(optname1: *const c_char, ...) -> *mut SoupAuthDomain;
    pub fn soup_auth_domain_digest_encode_password(username: *const c_char, realm: *const c_char, password: *const c_char) -> *mut c_char;

    //=========================================================================
    // SoupAuthManager
    //=========================================================================
    pub fn soup_auth_manager_get_type() -> GType;
    #[cfg(feature = "v2_42")]
    pub fn soup_auth_manager_use_auth(manager: *mut SoupAuthManager, uri: *mut SoupURI, auth: *mut SoupAuth);

    //=========================================================================
    // SoupAuthNTLM
    //=========================================================================
    pub fn soup_auth_ntlm_get_type() -> GType;

    //=========================================================================
    // SoupAuthNegotiate
    //=========================================================================
    pub fn soup_auth_negotiate_get_type() -> GType;
    #[cfg(feature = "v2_54")]
    pub fn soup_auth_negotiate_supported() -> gboolean;

    //=========================================================================
    // SoupCache
    //=========================================================================
    pub fn soup_cache_get_type() -> GType;
    #[cfg(feature = "v2_34")]
    pub fn soup_cache_new(cache_dir: *const c_char, cache_type: SoupCacheType) -> *mut SoupCache;
    #[cfg(feature = "v2_34")]
    pub fn soup_cache_clear(cache: *mut SoupCache);
    #[cfg(feature = "v2_34")]
    pub fn soup_cache_dump(cache: *mut SoupCache);
    #[cfg(feature = "v2_34")]
    pub fn soup_cache_flush(cache: *mut SoupCache);
    #[cfg(feature = "v2_34")]
    pub fn soup_cache_get_max_size(cache: *mut SoupCache) -> c_uint;
    #[cfg(feature = "v2_34")]
    pub fn soup_cache_load(cache: *mut SoupCache);
    #[cfg(feature = "v2_34")]
    pub fn soup_cache_set_max_size(cache: *mut SoupCache, max_size: c_uint);

    //=========================================================================
    // SoupContentDecoder
    //=========================================================================
    pub fn soup_content_decoder_get_type() -> GType;

    //=========================================================================
    // SoupContentSniffer
    //=========================================================================
    pub fn soup_content_sniffer_get_type() -> GType;
    #[cfg(feature = "v2_28")]
    pub fn soup_content_sniffer_new() -> *mut SoupContentSniffer;
    #[cfg(feature = "v2_28")]
    pub fn soup_content_sniffer_get_buffer_size(sniffer: *mut SoupContentSniffer) -> size_t;
    #[cfg(feature = "v2_28")]
    pub fn soup_content_sniffer_sniff(sniffer: *mut SoupContentSniffer, msg: *mut SoupMessage, buffer: *mut SoupBuffer, params: *mut *mut glib::GHashTable) -> *mut c_char;

    //=========================================================================
    // SoupCookieJar
    //=========================================================================
    pub fn soup_cookie_jar_get_type() -> GType;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_jar_new() -> *mut SoupCookieJar;
    #[cfg(feature = "v2_26")]
    pub fn soup_cookie_jar_add_cookie(jar: *mut SoupCookieJar, cookie: *mut SoupCookie);
    #[cfg(feature = "v2_40")]
    pub fn soup_cookie_jar_add_cookie_with_first_party(jar: *mut SoupCookieJar, first_party: *mut SoupURI, cookie: *mut SoupCookie);
    #[cfg(feature = "v2_26")]
    pub fn soup_cookie_jar_all_cookies(jar: *mut SoupCookieJar) -> *mut glib::GSList;
    #[cfg(feature = "v2_26")]
    pub fn soup_cookie_jar_delete_cookie(jar: *mut SoupCookieJar, cookie: *mut SoupCookie);
    #[cfg(feature = "v2_30")]
    pub fn soup_cookie_jar_get_accept_policy(jar: *mut SoupCookieJar) -> SoupCookieJarAcceptPolicy;
    #[cfg(feature = "v2_40")]
    pub fn soup_cookie_jar_get_cookie_list(jar: *mut SoupCookieJar, uri: *mut SoupURI, for_http: gboolean) -> *mut glib::GSList;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_jar_get_cookies(jar: *mut SoupCookieJar, uri: *mut SoupURI, for_http: gboolean) -> *mut c_char;
    #[cfg(feature = "v2_40")]
    pub fn soup_cookie_jar_is_persistent(jar: *mut SoupCookieJar) -> gboolean;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_jar_save(jar: *mut SoupCookieJar);
    #[cfg(feature = "v2_30")]
    pub fn soup_cookie_jar_set_accept_policy(jar: *mut SoupCookieJar, policy: SoupCookieJarAcceptPolicy);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookie_jar_set_cookie(jar: *mut SoupCookieJar, uri: *mut SoupURI, cookie: *const c_char);
    #[cfg(feature = "v2_30")]
    pub fn soup_cookie_jar_set_cookie_with_first_party(jar: *mut SoupCookieJar, uri: *mut SoupURI, first_party: *mut SoupURI, cookie: *const c_char);

    //=========================================================================
    // SoupCookieJarDB
    //=========================================================================
    pub fn soup_cookie_jar_db_get_type() -> GType;
    #[cfg(feature = "v2_42")]
    pub fn soup_cookie_jar_db_new(filename: *const c_char, read_only: gboolean) -> *mut SoupCookieJar;

    //=========================================================================
    // SoupCookieJarText
    //=========================================================================
    pub fn soup_cookie_jar_text_get_type() -> GType;
    #[cfg(feature = "v2_26")]
    pub fn soup_cookie_jar_text_new(filename: *const c_char, read_only: gboolean) -> *mut SoupCookieJar;

    //=========================================================================
    // SoupLogger
    //=========================================================================
    pub fn soup_logger_get_type() -> GType;
    pub fn soup_logger_new(level: SoupLoggerLogLevel, max_body_size: c_int) -> *mut SoupLogger;
    pub fn soup_logger_attach(logger: *mut SoupLogger, session: *mut SoupSession);
    pub fn soup_logger_detach(logger: *mut SoupLogger, session: *mut SoupSession);
    pub fn soup_logger_set_printer(logger: *mut SoupLogger, printer: SoupLoggerPrinter, printer_data: gpointer, destroy: glib::GDestroyNotify);
    pub fn soup_logger_set_request_filter(logger: *mut SoupLogger, request_filter: SoupLoggerFilter, filter_data: gpointer, destroy: glib::GDestroyNotify);
    pub fn soup_logger_set_response_filter(logger: *mut SoupLogger, response_filter: SoupLoggerFilter, filter_data: gpointer, destroy: glib::GDestroyNotify);

    //=========================================================================
    // SoupMessage
    //=========================================================================
    pub fn soup_message_get_type() -> GType;
    pub fn soup_message_new(method: *const c_char, uri_string: *const c_char) -> *mut SoupMessage;
    pub fn soup_message_new_from_uri(method: *const c_char, uri: *mut SoupURI) -> *mut SoupMessage;
    pub fn soup_message_add_header_handler(msg: *mut SoupMessage, signal: *const c_char, header: *const c_char, callback: gobject::GCallback, user_data: gpointer) -> c_uint;
    pub fn soup_message_add_status_code_handler(msg: *mut SoupMessage, signal: *const c_char, status_code: c_uint, callback: gobject::GCallback, user_data: gpointer) -> c_uint;
    pub fn soup_message_content_sniffed(msg: *mut SoupMessage, content_type: *const c_char, params: *mut glib::GHashTable);
    #[cfg(feature = "v2_28")]
    pub fn soup_message_disable_feature(msg: *mut SoupMessage, feature_type: GType);
    pub fn soup_message_finished(msg: *mut SoupMessage);
    #[cfg(feature = "v2_26")]
    pub fn soup_message_get_address(msg: *mut SoupMessage) -> *mut SoupAddress;
    #[cfg(feature = "v2_30")]
    pub fn soup_message_get_first_party(msg: *mut SoupMessage) -> *mut SoupURI;
    pub fn soup_message_get_flags(msg: *mut SoupMessage) -> SoupMessageFlags;
    pub fn soup_message_get_http_version(msg: *mut SoupMessage) -> SoupHTTPVersion;
    #[cfg(feature = "v2_34")]
    pub fn soup_message_get_https_status(msg: *mut SoupMessage, certificate: *mut *mut gio::GTlsCertificate, errors: *mut gio::GTlsCertificateFlags) -> gboolean;
    #[cfg(feature = "v2_44")]
    pub fn soup_message_get_priority(msg: *mut SoupMessage) -> SoupMessagePriority;
    #[cfg(feature = "v2_42")]
    pub fn soup_message_get_soup_request(msg: *mut SoupMessage) -> *mut SoupRequest;
    pub fn soup_message_get_uri(msg: *mut SoupMessage) -> *mut SoupURI;
    pub fn soup_message_got_body(msg: *mut SoupMessage);
    pub fn soup_message_got_chunk(msg: *mut SoupMessage, chunk: *mut SoupBuffer);
    pub fn soup_message_got_headers(msg: *mut SoupMessage);
    pub fn soup_message_got_informational(msg: *mut SoupMessage);
    pub fn soup_message_is_keepalive(msg: *mut SoupMessage) -> gboolean;
    pub fn soup_message_restarted(msg: *mut SoupMessage);
    pub fn soup_message_set_chunk_allocator(msg: *mut SoupMessage, allocator: SoupChunkAllocator, user_data: gpointer, destroy_notify: glib::GDestroyNotify);
    #[cfg(feature = "v2_30")]
    pub fn soup_message_set_first_party(msg: *mut SoupMessage, first_party: *mut SoupURI);
    pub fn soup_message_set_flags(msg: *mut SoupMessage, flags: SoupMessageFlags);
    pub fn soup_message_set_http_version(msg: *mut SoupMessage, version: SoupHTTPVersion);
    #[cfg(feature = "v2_44")]
    pub fn soup_message_set_priority(msg: *mut SoupMessage, priority: SoupMessagePriority);
    #[cfg(feature = "v2_38")]
    pub fn soup_message_set_redirect(msg: *mut SoupMessage, status_code: c_uint, redirect_uri: *const c_char);
    pub fn soup_message_set_request(msg: *mut SoupMessage, content_type: *const c_char, req_use: SoupMemoryUse, req_body: *mut u8, req_length: size_t);
    pub fn soup_message_set_response(msg: *mut SoupMessage, content_type: *const c_char, resp_use: SoupMemoryUse, resp_body: *mut u8, resp_length: size_t);
    pub fn soup_message_set_status(msg: *mut SoupMessage, status_code: c_uint);
    pub fn soup_message_set_status_full(msg: *mut SoupMessage, status_code: c_uint, reason_phrase: *const c_char);
    pub fn soup_message_set_uri(msg: *mut SoupMessage, uri: *mut SoupURI);
    pub fn soup_message_starting(msg: *mut SoupMessage);
    pub fn soup_message_wrote_body(msg: *mut SoupMessage);
    pub fn soup_message_wrote_body_data(msg: *mut SoupMessage, chunk: *mut SoupBuffer);
    pub fn soup_message_wrote_chunk(msg: *mut SoupMessage);
    pub fn soup_message_wrote_headers(msg: *mut SoupMessage);
    pub fn soup_message_wrote_informational(msg: *mut SoupMessage);

    //=========================================================================
    // SoupMultipartInputStream
    //=========================================================================
    pub fn soup_multipart_input_stream_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn soup_multipart_input_stream_new(msg: *mut SoupMessage, base_stream: *mut gio::GInputStream) -> *mut SoupMultipartInputStream;
    #[cfg(feature = "v2_40")]
    pub fn soup_multipart_input_stream_get_headers(multipart: *mut SoupMultipartInputStream) -> *mut SoupMessageHeaders;
    #[cfg(feature = "v2_40")]
    pub fn soup_multipart_input_stream_next_part(multipart: *mut SoupMultipartInputStream, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut gio::GInputStream;
    #[cfg(feature = "v2_40")]
    pub fn soup_multipart_input_stream_next_part_async(multipart: *mut SoupMultipartInputStream, io_priority: c_int, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, data: gpointer);
    #[cfg(feature = "v2_40")]
    pub fn soup_multipart_input_stream_next_part_finish(multipart: *mut SoupMultipartInputStream, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut gio::GInputStream;

    //=========================================================================
    // SoupProxyResolverDefault
    //=========================================================================
    pub fn soup_proxy_resolver_default_get_type() -> GType;

    //=========================================================================
    // SoupRequest
    //=========================================================================
    pub fn soup_request_get_type() -> GType;
    #[cfg(feature = "v2_42")]
    pub fn soup_request_get_content_length(request: *mut SoupRequest) -> i64;
    #[cfg(feature = "v2_42")]
    pub fn soup_request_get_content_type(request: *mut SoupRequest) -> *const c_char;
    #[cfg(feature = "v2_42")]
    pub fn soup_request_get_session(request: *mut SoupRequest) -> *mut SoupSession;
    #[cfg(feature = "v2_42")]
    pub fn soup_request_get_uri(request: *mut SoupRequest) -> *mut SoupURI;
    #[cfg(feature = "v2_42")]
    pub fn soup_request_send(request: *mut SoupRequest, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut gio::GInputStream;
    #[cfg(feature = "v2_42")]
    pub fn soup_request_send_async(request: *mut SoupRequest, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_42")]
    pub fn soup_request_send_finish(request: *mut SoupRequest, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut gio::GInputStream;

    //=========================================================================
    // SoupRequestData
    //=========================================================================
    pub fn soup_request_data_get_type() -> GType;

    //=========================================================================
    // SoupRequestFile
    //=========================================================================
    pub fn soup_request_file_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn soup_request_file_get_file(file: *mut SoupRequestFile) -> *mut gio::GFile;

    //=========================================================================
    // SoupRequestHTTP
    //=========================================================================
    pub fn soup_request_http_get_type() -> GType;
    #[cfg(feature = "v2_40")]
    pub fn soup_request_http_get_message(http: *mut SoupRequestHTTP) -> *mut SoupMessage;

    //=========================================================================
    // SoupRequester
    //=========================================================================
    pub fn soup_requester_get_type() -> GType;
    pub fn soup_requester_new() -> *mut SoupRequester;
    pub fn soup_requester_request(requester: *mut SoupRequester, uri_string: *const c_char, error: *mut *mut glib::GError) -> *mut SoupRequest;
    pub fn soup_requester_request_uri(requester: *mut SoupRequester, uri: *mut SoupURI, error: *mut *mut glib::GError) -> *mut SoupRequest;

    //=========================================================================
    // SoupServer
    //=========================================================================
    pub fn soup_server_get_type() -> GType;
    pub fn soup_server_new(optname1: *const c_char, ...) -> *mut SoupServer;
    #[cfg(feature = "v2_50")]
    pub fn soup_server_accept_iostream(server: *mut SoupServer, stream: *mut gio::GIOStream, local_addr: *mut gio::GSocketAddress, remote_addr: *mut gio::GSocketAddress, error: *mut *mut glib::GError) -> gboolean;
    pub fn soup_server_add_auth_domain(server: *mut SoupServer, auth_domain: *mut SoupAuthDomain);
    #[cfg(feature = "v2_50")]
    pub fn soup_server_add_early_handler(server: *mut SoupServer, path: *const c_char, callback: SoupServerCallback, user_data: gpointer, destroy: glib::GDestroyNotify);
    pub fn soup_server_add_handler(server: *mut SoupServer, path: *const c_char, callback: SoupServerCallback, user_data: gpointer, destroy: glib::GDestroyNotify);
    pub fn soup_server_add_websocket_handler(server: *mut SoupServer, path: *const c_char, origin: *const c_char, protocols: *mut *mut c_char, callback: SoupServerWebsocketCallback, user_data: gpointer, destroy: glib::GDestroyNotify);
    pub fn soup_server_disconnect(server: *mut SoupServer);
    pub fn soup_server_get_async_context(server: *mut SoupServer) -> *mut glib::GMainContext;
    pub fn soup_server_get_listener(server: *mut SoupServer) -> *mut SoupSocket;
    pub fn soup_server_get_listeners(server: *mut SoupServer) -> *mut glib::GSList;
    pub fn soup_server_get_port(server: *mut SoupServer) -> c_uint;
    #[cfg(feature = "v2_48")]
    pub fn soup_server_get_uris(server: *mut SoupServer) -> *mut glib::GSList;
    pub fn soup_server_is_https(server: *mut SoupServer) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn soup_server_listen(server: *mut SoupServer, address: *mut gio::GSocketAddress, options: SoupServerListenOptions, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn soup_server_listen_all(server: *mut SoupServer, port: c_uint, options: SoupServerListenOptions, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn soup_server_listen_fd(server: *mut SoupServer, fd: c_int, options: SoupServerListenOptions, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn soup_server_listen_local(server: *mut SoupServer, port: c_uint, options: SoupServerListenOptions, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_48")]
    pub fn soup_server_listen_socket(server: *mut SoupServer, socket: *mut gio::GSocket, options: SoupServerListenOptions, error: *mut *mut glib::GError) -> gboolean;
    pub fn soup_server_pause_message(server: *mut SoupServer, msg: *mut SoupMessage);
    pub fn soup_server_quit(server: *mut SoupServer);
    pub fn soup_server_remove_auth_domain(server: *mut SoupServer, auth_domain: *mut SoupAuthDomain);
    pub fn soup_server_remove_handler(server: *mut SoupServer, path: *const c_char);
    pub fn soup_server_run(server: *mut SoupServer);
    pub fn soup_server_run_async(server: *mut SoupServer);
    #[cfg(feature = "v2_48")]
    pub fn soup_server_set_ssl_cert_file(server: *mut SoupServer, ssl_cert_file: *const c_char, ssl_key_file: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn soup_server_unpause_message(server: *mut SoupServer, msg: *mut SoupMessage);

    //=========================================================================
    // SoupSession
    //=========================================================================
    pub fn soup_session_get_type() -> GType;
    #[cfg(feature = "v2_42")]
    pub fn soup_session_new() -> *mut SoupSession;
    #[cfg(feature = "v2_42")]
    pub fn soup_session_new_with_options(optname1: *const c_char, ...) -> *mut SoupSession;
    pub fn soup_session_abort(session: *mut SoupSession);
    #[cfg(feature = "v2_24")]
    pub fn soup_session_add_feature(session: *mut SoupSession, feature: *mut SoupSessionFeature);
    #[cfg(feature = "v2_24")]
    pub fn soup_session_add_feature_by_type(session: *mut SoupSession, feature_type: GType);
    pub fn soup_session_cancel_message(session: *mut SoupSession, msg: *mut SoupMessage, status_code: c_uint);
    pub fn soup_session_get_async_context(session: *mut SoupSession) -> *mut glib::GMainContext;
    #[cfg(feature = "v2_26")]
    pub fn soup_session_get_feature(session: *mut SoupSession, feature_type: GType) -> *mut SoupSessionFeature;
    #[cfg(feature = "v2_28")]
    pub fn soup_session_get_feature_for_message(session: *mut SoupSession, feature_type: GType, msg: *mut SoupMessage) -> *mut SoupSessionFeature;
    #[cfg(feature = "v2_26")]
    pub fn soup_session_get_features(session: *mut SoupSession, feature_type: GType) -> *mut glib::GSList;
    #[cfg(feature = "v2_42")]
    pub fn soup_session_has_feature(session: *mut SoupSession, feature_type: GType) -> gboolean;
    pub fn soup_session_pause_message(session: *mut SoupSession, msg: *mut SoupMessage);
    #[cfg(feature = "v2_38")]
    pub fn soup_session_prefetch_dns(session: *mut SoupSession, hostname: *const c_char, cancellable: *mut gio::GCancellable, callback: SoupAddressCallback, user_data: gpointer);
    #[cfg(feature = "v2_30")]
    pub fn soup_session_prepare_for_uri(session: *mut SoupSession, uri: *mut SoupURI);
    pub fn soup_session_queue_message(session: *mut SoupSession, msg: *mut SoupMessage, callback: SoupSessionCallback, user_data: gpointer);
    #[cfg(feature = "v2_38")]
    pub fn soup_session_redirect_message(session: *mut SoupSession, msg: *mut SoupMessage) -> gboolean;
    #[cfg(feature = "v2_24")]
    pub fn soup_session_remove_feature(session: *mut SoupSession, feature: *mut SoupSessionFeature);
    #[cfg(feature = "v2_24")]
    pub fn soup_session_remove_feature_by_type(session: *mut SoupSession, feature_type: GType);
    #[cfg(feature = "v2_42")]
    pub fn soup_session_request(session: *mut SoupSession, uri_string: *const c_char, error: *mut *mut glib::GError) -> *mut SoupRequest;
    #[cfg(feature = "v2_42")]
    pub fn soup_session_request_http(session: *mut SoupSession, method: *const c_char, uri_string: *const c_char, error: *mut *mut glib::GError) -> *mut SoupRequestHTTP;
    #[cfg(feature = "v2_42")]
    pub fn soup_session_request_http_uri(session: *mut SoupSession, method: *const c_char, uri: *mut SoupURI, error: *mut *mut glib::GError) -> *mut SoupRequestHTTP;
    #[cfg(feature = "v2_42")]
    pub fn soup_session_request_uri(session: *mut SoupSession, uri: *mut SoupURI, error: *mut *mut glib::GError) -> *mut SoupRequest;
    pub fn soup_session_requeue_message(session: *mut SoupSession, msg: *mut SoupMessage);
    #[cfg(feature = "v2_42")]
    pub fn soup_session_send(session: *mut SoupSession, msg: *mut SoupMessage, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut gio::GInputStream;
    #[cfg(feature = "v2_42")]
    pub fn soup_session_send_async(session: *mut SoupSession, msg: *mut SoupMessage, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_42")]
    pub fn soup_session_send_finish(session: *mut SoupSession, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut gio::GInputStream;
    pub fn soup_session_send_message(session: *mut SoupSession, msg: *mut SoupMessage) -> c_uint;
    #[cfg(feature = "v2_50")]
    pub fn soup_session_steal_connection(session: *mut SoupSession, msg: *mut SoupMessage) -> *mut gio::GIOStream;
    pub fn soup_session_unpause_message(session: *mut SoupSession, msg: *mut SoupMessage);
    #[cfg(feature = "v2_50")]
    pub fn soup_session_websocket_connect_async(session: *mut SoupSession, msg: *mut SoupMessage, origin: *const c_char, protocols: *mut *mut c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(feature = "v2_50")]
    pub fn soup_session_websocket_connect_finish(session: *mut SoupSession, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut SoupWebsocketConnection;
    #[cfg(feature = "v2_38")]
    pub fn soup_session_would_redirect(session: *mut SoupSession, msg: *mut SoupMessage) -> gboolean;

    //=========================================================================
    // SoupSessionAsync
    //=========================================================================
    pub fn soup_session_async_get_type() -> GType;
    pub fn soup_session_async_new() -> *mut SoupSession;
    pub fn soup_session_async_new_with_options(optname1: *const c_char, ...) -> *mut SoupSession;

    //=========================================================================
    // SoupSessionSync
    //=========================================================================
    pub fn soup_session_sync_get_type() -> GType;
    pub fn soup_session_sync_new() -> *mut SoupSession;
    pub fn soup_session_sync_new_with_options(optname1: *const c_char, ...) -> *mut SoupSession;

    //=========================================================================
    // SoupSocket
    //=========================================================================
    pub fn soup_socket_get_type() -> GType;
    pub fn soup_socket_new(optname1: *const c_char, ...) -> *mut SoupSocket;
    pub fn soup_socket_connect_async(sock: *mut SoupSocket, cancellable: *mut gio::GCancellable, callback: SoupSocketCallback, user_data: gpointer);
    pub fn soup_socket_connect_sync(sock: *mut SoupSocket, cancellable: *mut gio::GCancellable) -> c_uint;
    pub fn soup_socket_disconnect(sock: *mut SoupSocket);
    pub fn soup_socket_get_fd(sock: *mut SoupSocket) -> c_int;
    pub fn soup_socket_get_local_address(sock: *mut SoupSocket) -> *mut SoupAddress;
    pub fn soup_socket_get_remote_address(sock: *mut SoupSocket) -> *mut SoupAddress;
    pub fn soup_socket_is_connected(sock: *mut SoupSocket) -> gboolean;
    pub fn soup_socket_is_ssl(sock: *mut SoupSocket) -> gboolean;
    pub fn soup_socket_listen(sock: *mut SoupSocket) -> gboolean;
    pub fn soup_socket_read(sock: *mut SoupSocket, buffer: gpointer, len: size_t, nread: *mut size_t, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> SoupSocketIOStatus;
    pub fn soup_socket_read_until(sock: *mut SoupSocket, buffer: gpointer, len: size_t, boundary: gconstpointer, boundary_len: size_t, nread: *mut size_t, got_boundary: *mut gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> SoupSocketIOStatus;
    pub fn soup_socket_start_proxy_ssl(sock: *mut SoupSocket, ssl_host: *const c_char, cancellable: *mut gio::GCancellable) -> gboolean;
    pub fn soup_socket_start_ssl(sock: *mut SoupSocket, cancellable: *mut gio::GCancellable) -> gboolean;
    pub fn soup_socket_write(sock: *mut SoupSocket, buffer: gconstpointer, len: size_t, nwrote: *mut size_t, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> SoupSocketIOStatus;

    //=========================================================================
    // SoupWebsocketConnection
    //=========================================================================
    pub fn soup_websocket_connection_get_type() -> GType;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_new(stream: *mut gio::GIOStream, uri: *mut SoupURI, type_: SoupWebsocketConnectionType, origin: *const c_char, protocol: *const c_char) -> *mut SoupWebsocketConnection;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_close(self_: *mut SoupWebsocketConnection, code: c_ushort, data: *const c_char);
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_close_code(self_: *mut SoupWebsocketConnection) -> c_ushort;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_close_data(self_: *mut SoupWebsocketConnection) -> *const c_char;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_connection_type(self_: *mut SoupWebsocketConnection) -> SoupWebsocketConnectionType;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_io_stream(self_: *mut SoupWebsocketConnection) -> *mut gio::GIOStream;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_origin(self_: *mut SoupWebsocketConnection) -> *const c_char;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_protocol(self_: *mut SoupWebsocketConnection) -> *const c_char;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_state(self_: *mut SoupWebsocketConnection) -> SoupWebsocketState;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_get_uri(self_: *mut SoupWebsocketConnection) -> *mut SoupURI;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_send_binary(self_: *mut SoupWebsocketConnection, data: gconstpointer, length: size_t);
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_connection_send_text(self_: *mut SoupWebsocketConnection, text: *const c_char);

    //=========================================================================
    // SoupPasswordManager
    //=========================================================================
    pub fn soup_password_manager_get_type() -> GType;
    pub fn soup_password_manager_get_passwords_async(password_manager: *mut SoupPasswordManager, msg: *mut SoupMessage, auth: *mut SoupAuth, retrying: gboolean, async_context: *mut glib::GMainContext, cancellable: *mut gio::GCancellable, callback: SoupPasswordManagerCallback, user_data: gpointer);
    pub fn soup_password_manager_get_passwords_sync(password_manager: *mut SoupPasswordManager, msg: *mut SoupMessage, auth: *mut SoupAuth, cancellable: *mut gio::GCancellable);

    //=========================================================================
    // SoupProxyURIResolver
    //=========================================================================
    pub fn soup_proxy_uri_resolver_get_type() -> GType;
    #[cfg(feature = "v2_26_3")]
    pub fn soup_proxy_uri_resolver_get_proxy_uri_async(proxy_uri_resolver: *mut SoupProxyURIResolver, uri: *mut SoupURI, async_context: *mut glib::GMainContext, cancellable: *mut gio::GCancellable, callback: SoupProxyURIResolverCallback, user_data: gpointer);
    #[cfg(feature = "v2_26_3")]
    pub fn soup_proxy_uri_resolver_get_proxy_uri_sync(proxy_uri_resolver: *mut SoupProxyURIResolver, uri: *mut SoupURI, cancellable: *mut gio::GCancellable, proxy_uri: *mut *mut SoupURI) -> c_uint;

    //=========================================================================
    // SoupSessionFeature
    //=========================================================================
    pub fn soup_session_feature_get_type() -> GType;
    #[cfg(feature = "v2_34")]
    pub fn soup_session_feature_add_feature(feature: *mut SoupSessionFeature, type_: GType) -> gboolean;
    pub fn soup_session_feature_attach(feature: *mut SoupSessionFeature, session: *mut SoupSession);
    pub fn soup_session_feature_detach(feature: *mut SoupSessionFeature, session: *mut SoupSession);
    #[cfg(feature = "v2_34")]
    pub fn soup_session_feature_has_feature(feature: *mut SoupSessionFeature, type_: GType) -> gboolean;
    #[cfg(feature = "v2_34")]
    pub fn soup_session_feature_remove_feature(feature: *mut SoupSessionFeature, type_: GType) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(feature = "v2_24")]
    pub fn soup_add_completion(async_context: *mut glib::GMainContext, function: glib::GSourceFunc, data: gpointer) -> *mut glib::GSource;
    pub fn soup_add_idle(async_context: *mut glib::GMainContext, function: glib::GSourceFunc, data: gpointer) -> *mut glib::GSource;
    pub fn soup_add_io_watch(async_context: *mut glib::GMainContext, chan: *mut glib::GIOChannel, condition: glib::GIOCondition, function: glib::GIOFunc, data: gpointer) -> *mut glib::GSource;
    pub fn soup_add_timeout(async_context: *mut glib::GMainContext, interval: c_uint, function: glib::GSourceFunc, data: gpointer) -> *mut glib::GSource;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookies_free(cookies: *mut glib::GSList);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookies_from_request(msg: *mut SoupMessage) -> *mut glib::GSList;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookies_from_response(msg: *mut SoupMessage) -> *mut glib::GSList;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookies_to_cookie_header(cookies: *mut glib::GSList) -> *mut c_char;
    #[cfg(feature = "v2_24")]
    pub fn soup_cookies_to_request(cookies: *mut glib::GSList, msg: *mut SoupMessage);
    #[cfg(feature = "v2_24")]
    pub fn soup_cookies_to_response(cookies: *mut glib::GSList, msg: *mut SoupMessage);
    pub fn soup_form_decode(encoded_form: *const c_char) -> *mut glib::GHashTable;
    #[cfg(feature = "v2_26")]
    pub fn soup_form_decode_multipart(msg: *mut SoupMessage, file_control_name: *const c_char, filename: *mut *mut c_char, content_type: *mut *mut c_char, file: *mut *mut SoupBuffer) -> *mut glib::GHashTable;
    pub fn soup_form_encode(first_field: *const c_char, ...) -> *mut c_char;
    pub fn soup_form_encode_datalist(form_data_set: *mut *mut glib::GData) -> *mut c_char;
    pub fn soup_form_encode_hash(form_data_set: *mut glib::GHashTable) -> *mut c_char;
    //pub fn soup_form_encode_valist(first_field: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn soup_form_request_new(method: *const c_char, uri: *const c_char, first_field: *const c_char, ...) -> *mut SoupMessage;
    pub fn soup_form_request_new_from_datalist(method: *const c_char, uri: *const c_char, form_data_set: *mut *mut glib::GData) -> *mut SoupMessage;
    pub fn soup_form_request_new_from_hash(method: *const c_char, uri: *const c_char, form_data_set: *mut glib::GHashTable) -> *mut SoupMessage;
    #[cfg(feature = "v2_26")]
    pub fn soup_form_request_new_from_multipart(uri: *const c_char, multipart: *mut SoupMultipart) -> *mut SoupMessage;
    pub fn soup_header_contains(header: *const c_char, token: *const c_char) -> gboolean;
    pub fn soup_header_free_list(list: *mut glib::GSList);
    pub fn soup_header_free_param_list(param_list: *mut glib::GHashTable);
    #[cfg(feature = "v2_26")]
    pub fn soup_header_g_string_append_param(string: *mut glib::GString, name: *const c_char, value: *const c_char);
    #[cfg(feature = "v2_30")]
    pub fn soup_header_g_string_append_param_quoted(string: *mut glib::GString, name: *const c_char, value: *const c_char);
    pub fn soup_header_parse_list(header: *const c_char) -> *mut glib::GSList;
    pub fn soup_header_parse_param_list(header: *const c_char) -> *mut glib::GHashTable;
    pub fn soup_header_parse_quality_list(header: *const c_char, unacceptable: *mut *mut glib::GSList) -> *mut glib::GSList;
    #[cfg(feature = "v2_24")]
    pub fn soup_header_parse_semi_param_list(header: *const c_char) -> *mut glib::GHashTable;
    #[cfg(feature = "v2_26")]
    pub fn soup_headers_parse(str: *const c_char, len: c_int, dest: *mut SoupMessageHeaders) -> gboolean;
    pub fn soup_headers_parse_request(str: *const c_char, len: c_int, req_headers: *mut SoupMessageHeaders, req_method: *mut *mut c_char, req_path: *mut *mut c_char, ver: *mut SoupHTTPVersion) -> c_uint;
    pub fn soup_headers_parse_response(str: *const c_char, len: c_int, headers: *mut SoupMessageHeaders, ver: *mut SoupHTTPVersion, status_code: *mut c_uint, reason_phrase: *mut *mut c_char) -> gboolean;
    pub fn soup_headers_parse_status_line(status_line: *const c_char, ver: *mut SoupHTTPVersion, status_code: *mut c_uint, reason_phrase: *mut *mut c_char) -> gboolean;
    pub fn soup_http_error_quark() -> glib::GQuark;
    pub fn soup_str_case_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn soup_str_case_hash(key: gconstpointer) -> c_uint;
    #[cfg(feature = "v2_40")]
    pub fn soup_tld_domain_is_public_suffix(domain: *const c_char) -> gboolean;
    #[cfg(feature = "v2_40")]
    pub fn soup_tld_get_base_domain(hostname: *const c_char, error: *mut *mut glib::GError) -> *const c_char;
    pub fn soup_value_array_append(array: *mut gobject::GValueArray, type_: GType, ...);
    pub fn soup_value_array_append_vals(array: *mut gobject::GValueArray, first_type: GType, ...);
    //pub fn soup_value_array_from_args(args: /*Unimplemented*/va_list) -> *mut gobject::GValueArray;
    pub fn soup_value_array_get_nth(array: *mut gobject::GValueArray, index_: c_uint, type_: GType, ...) -> gboolean;
    pub fn soup_value_array_insert(array: *mut gobject::GValueArray, index_: c_uint, type_: GType, ...);
    pub fn soup_value_array_new() -> *mut gobject::GValueArray;
    pub fn soup_value_array_new_with_vals(first_type: GType, ...) -> *mut gobject::GValueArray;
    //pub fn soup_value_array_to_args(array: *mut gobject::GValueArray, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn soup_value_hash_insert(hash: *mut glib::GHashTable, key: *const c_char, type_: GType, ...);
    pub fn soup_value_hash_insert_vals(hash: *mut glib::GHashTable, first_key: *const c_char, ...);
    pub fn soup_value_hash_insert_value(hash: *mut glib::GHashTable, key: *const c_char, value: *mut gobject::GValue);
    pub fn soup_value_hash_lookup(hash: *mut glib::GHashTable, key: *const c_char, type_: GType, ...) -> gboolean;
    pub fn soup_value_hash_lookup_vals(hash: *mut glib::GHashTable, first_key: *const c_char, ...) -> gboolean;
    pub fn soup_value_hash_new() -> *mut glib::GHashTable;
    pub fn soup_value_hash_new_with_vals(first_key: *const c_char, ...) -> *mut glib::GHashTable;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_client_prepare_handshake(msg: *mut SoupMessage, origin: *const c_char, protocols: *mut *mut c_char);
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_client_verify_handshake(msg: *mut SoupMessage, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_server_check_handshake(msg: *mut SoupMessage, origin: *const c_char, protocols: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_50")]
    pub fn soup_websocket_server_process_handshake(msg: *mut SoupMessage, expected_origin: *const c_char, protocols: *mut *mut c_char) -> gboolean;
    pub fn soup_xmlrpc_build_fault(fault_code: c_int, fault_format: *const c_char, ...) -> *mut c_char;
    pub fn soup_xmlrpc_build_method_call(method_name: *const c_char, params: *mut gobject::GValue, n_params: c_int) -> *mut c_char;
    pub fn soup_xmlrpc_build_method_response(value: *mut gobject::GValue) -> *mut c_char;
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_build_request(method_name: *const c_char, params: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_build_response(value: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn soup_xmlrpc_extract_method_call(method_call: *const c_char, length: c_int, method_name: *mut *mut c_char, ...) -> gboolean;
    pub fn soup_xmlrpc_extract_method_response(method_response: *const c_char, length: c_int, error: *mut *mut glib::GError, type_: GType, ...) -> gboolean;
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_message_new(uri: *const c_char, method_name: *const c_char, params: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut SoupMessage;
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_message_set_fault(msg: *mut SoupMessage, fault_code: c_int, fault_format: *const c_char, ...);
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_message_set_response(msg: *mut SoupMessage, value: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn soup_xmlrpc_parse_method_call(method_call: *const c_char, length: c_int, method_name: *mut *mut c_char, params: *mut *mut gobject::GValueArray) -> gboolean;
    pub fn soup_xmlrpc_parse_method_response(method_response: *const c_char, length: c_int, value: *mut gobject::GValue, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_parse_request(method_call: *const c_char, length: c_int, params: *mut *mut SoupXMLRPCParams, error: *mut *mut glib::GError) -> *mut c_char;
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_parse_response(method_response: *const c_char, length: c_int, signature: *const c_char, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn soup_xmlrpc_request_new(uri: *const c_char, method_name: *const c_char, ...) -> *mut SoupMessage;
    pub fn soup_xmlrpc_set_fault(msg: *mut SoupMessage, fault_code: c_int, fault_format: *const c_char, ...);
    pub fn soup_xmlrpc_set_response(msg: *mut SoupMessage, type_: GType, ...);
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_variant_get_datetime(variant: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut SoupDate;
    #[cfg(feature = "v2_52")]
    pub fn soup_xmlrpc_variant_new_datetime(date: *mut SoupDate) -> *mut glib::GVariant;

}
